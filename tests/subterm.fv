data Nat : Set :=
  | zero :
  | succ : Nat
  ;

natInduction : (Φ : Nat → Set 2) →
               (Φ zero) →
               ((n : Nat) → Φ n → Φ (succ n)) →
               (n : Nat) → Φ n;
natInduction Φ φ0 φS =
  induction NatDesc Φ
            (\x. case x for x. lift NatDesc Nat Φ x → Φ (construct x) with
                    { inl u. \u'. φ0
                    ; inr n. \φn. φS n φn
                    });

natCase : (A : Nat → Set 2) → A zero → ((n : Nat) → A (succ n)) → (n : Nat) → A n;
natCase A a f = induction NatDesc A
                          (λx p. case x for x. A (construct x) with
                                    { inl u. a
                                    ; inr n. f n
                                    });

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
Bool : Set;
Bool = Unit + Unit;

body : Nat × Nat → Bool → IDesc (Nat × Nat);
body p x =
  case x with
    { inl u. “K” (zero ≡ fst p)
    ; inr u. “Σ” Nat (λn₁. “Σ” Nat (λn₂. “IId” «n₁,n₂» “×” “K” (succ n₁ ≡ fst p) “×” “K” (succ n₂ ≡ snd p)))
    }

LeqDesc : (Nat × Nat) → IDesc (Nat × Nat);
LeqDesc p =
  “Σ” Bool (body p);

Leq : Nat → Nat → Set;
Leq n₁ n₂ = µI (Nat × Nat) LeqDesc «n₁, n₂»;

leqZero : (n : Nat) → Leq zero n;
leqZero n = construct «inl (), refl»;

leqSucc : (n₁ n₂ : Nat) → Leq n₁ n₂ → Leq (succ n₁) (succ n₂);
leqSucc n₁ n₂ x = construct «inr (), n₁, n₂, x, refl, refl»;

leqRefl : (n : Nat) → Leq n n;
leqRefl =
  natInduction (λn. Leq n n)
    (leqZero zero)
    (λn n_leq_n. leqSucc n n n_leq_n);

leqInduction :
  (P : (n₁ n₂ : Nat) → Leq n₁ n₂ → Set 2) →
  ((n₂ : Nat) → P zero n₂ (leqZero n₂)) →
  ((n₁ n₂ : Nat) → (x : Leq n₁ n₂) → P n₁ n₂ x → P (succ n₁) (succ n₂) (leqSucc n₁ n₂ x)) →
  (n₁ n₂ : Nat) →
  (x : Leq n₁ n₂) →
  P n₁ n₂ x;
leqInduction P φzero φsucc n₁ n₂ =
  inductionI (Nat × Nat) LeqDesc
    (λp x. P (fst p) (snd p) x)
    (λp x. case fst x for b. (z : semI[body p b, p. Leq (fst p) (snd p)]) →
                             liftI[body p b, p. Leq (fst p) (snd p), p x. P (fst p) (snd p) x, z] →
                             P (fst p) (snd p) (construct «b, z») with
             { inl u. λz u.
                 elimEq z
                    for n' eq. P n' (snd p) (construct «inl (), eq»)
                   with (φzero (snd p))
             ; inr u. λz φ.
                 elimEq fst (snd (snd (snd z)))
                    for n₁ eq₁. P n₁ (snd p) (construct «inr (), fst z, fst (snd z), fst (snd (snd z)), eq₁, snd (snd (snd (snd z)))»)
                   with (elimEq snd (snd (snd (snd z)))
                            for n₂ eq₂. P (succ (fst z)) n₂ (construct «inr (), fst z, fst (snd z), fst (snd (snd z)), refl, eq₂»)
                           with (φsucc (fst z) (fst (snd z)) (fst (snd (snd z))) (fst φ)))
             } (snd x))
    «n₁, n₂»;

succ≢zero : (n : Nat) → succ n ≡ zero → Empty;
succ≢zero n eq =
  elimEq eq for n p. natCase (λn. Set) Empty (λu. Unit) n with ();

symm :
  (α : Set) →
  (a₁ a₂ : α) →
  a₁ ≡ a₂ →
  a₂ ≡ a₁;
symm α a₁ a₂ eq =
  elimEq eq for a p. a ≡ a₁ with refl;

succ-inj : (n₁ n₂ : Nat) → succ n₁ ≡ succ n₂ → n₁ ≡ n₂;
succ-inj n₁ n₂ eq =
  elimEq symm Nat (succ n₁) (succ n₂) eq
    for n p. natCase (λn. Set) Empty (λn. n ≡ n₂) n
    with refl;

elim-leqSucc :
  (Φ : (n₁ n₂ : Nat) → Leq (succ n₁) n₂ → Set) →
  ((n₁ n₂ : Nat) → (le : Leq n₁ n₂) → Φ n₁ (succ n₂) (leqSucc n₁ n₂ le)) →
  (n₁ n₂ : Nat) →
  (le : Leq (succ n₁) n₂) →
  Φ n₁ n₂ le;
elim-leqSucc Φ φsucc n₁ n₂ le =
  leqInduction (λn₁ n₂ le. (n'₁ : Nat) → (le' : Leq (succ n'₁) n₂) → n₁ ≡ succ n'₁ → le ≡ le' → Φ n'₁ n₂ le')
    (λn₂ n'₁ le' zero≡succ eq₂.
      elimEmpty (succ≢zero n'₁ (symm Nat zero (succ n'₁) zero≡succ)))
    (λn₁ n₂ le₀ φ₀ n'₁ le' eq₁.
      (elimEq succ-inj n₁ n'₁ eq₁
          for n'₁ p. (le' : Leq (succ n'₁) (succ n₂)) → leqSucc n₁ n₂ le₀ ≡ le' → Φ n'₁ (succ n₂) le'
         with λle' eq₂. elimEq eq₂ for le' p. Φ n₁ (succ n₂) le'
                         with φsucc n₁ n₂ le₀)
      le')
    (succ n₁) n₂ le n₁ le refl refl;

leqTrans :
  (n₁ n₂ n₃ : Nat) →
  Leq n₁ n₂ →
  Leq n₂ n₃ →
  Leq n₁ n₃;
leqTrans n₁ n₂ n₃ le₁ le₂ =
  leqInduction (λn₁ n₂ x. (n₃ : Nat) → Leq n₂ n₃ → Leq n₁ n₃)
    (λn₂ n₃ x. leqZero n₃)
    (λn₁ n₂ n φ n₃ succn₂-leq-n₃.
      elim-leqSucc
        (λn₂ n₃ le. ((n₃ : Nat) → Leq n₂ n₃ → Leq n₁ n₃) → Leq (succ n₁) n₃)
        (λn₂ n₃ le φ. leqSucc n₁ n₃ (φ n₃ le))
        n₂ n₃ succn₂-leq-n₃ φ)
    n₁ n₂ le₁ n₃ le₂;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– injectivity
injective : (α β : Set) → (f : α → β) → Set;
injective α β f = (a₁ a₂ : α) → f a₁ ≡ f a₂ → a₁ ≡ a₂;

f : (Nat × Nat) → (Nat × Nat);
f p = «succ (fst p), snd p»;

fst-eq : (α β : Set) → (x y : α × β) → x ≡ y → fst x ≡ fst y;
fst-eq α β x y eq = elimEq eq for y p. fst x ≡ fst y with refl;

snd-eq : (α β : Set) → (x y : α × β) → x ≡ y → snd x ≡ snd y;
snd-eq α β x y eq = elimEq eq for y p. snd x ≡ snd y with refl;

mkPair : (α β : Set) → α → β → α × β;
mkPair α β a b = «a,b»;

split : (α β : Set) → (x y : α × β) → fst x ≡ fst y → snd x ≡ snd y → x ≡ y;
split α β x y eq₁ eq₂ = rewriteBy eq₁ then rewriteBy eq₂ then refl

lem : injective (Nat × Nat) (Nat × Nat) f;
lem p₁ p₂ eq =
  split Nat Nat p₁ p₂
    (succ-inj (fst p₁) (fst p₂) (fst-eq Nat Nat «succ (fst p₁), snd p₁» «succ (fst p₂), snd p₂» eq))
    (snd-eq Nat Nat «succ (fst p₁), snd p₁» «succ (fst p₂), snd p₂» eq);

;