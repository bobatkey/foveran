sem : Desc → Set → Set ;
sem = elimD (λx. Set → Set)
            (λA X. A)
            (λX. X)
            (λF G semF semG X. semF X × semG X)
            (λF G semF semG X. semF X + semG X);

lift : (D : Desc) →
       (α : Set) →
       (Φ : α → Set 2) →
       sem D α →
       Set 2 ;
lift D α Φ = elimD (\D. sem D α → Set 2)
                   (\A x. Unit)
                   (\x. Φ x)
                   (\F G f g x. f (fst x) × g (snd x))
                   (\F G f g x. case x for d. Set 2 with
                                   { inl y. f y
                                   ; inr z. g z
                                   })
                   D;

all : (D : Desc) →
      (X : Set) →
      (P : X → Set 2) →
      (p : (x : X) → P x) →
      (xs : sem D X) →
      lift D X P xs ;
all D X P p = elimD (\D. (xs : sem D X) → lift D X P xs)
                    (\A x. ())
                    (\x. p x)
                    (\F G f g x. «f (fst x), g (snd x)»)
                    (\F G f g x. case x for d. lift (F “+” G) X P d with
                                    { inl y. f y
                                    ; inr z. g z
                                    }) 
                   D;

--assume induction : (D : Desc) →
--                   (P : µ D → Set 2) →
--                   (k : (x : sem D (µ D)) → lift D (µ D) P x → P (construct x)) →
--                   (x : µ D) →
--                   P x;

data Nat : Set :=
  | zero :
  | succ : Nat
  ;

natInduction : (Φ : Nat → Set 2) →
               (Φ zero) →
               ((n : Nat) → Φ n → Φ (succ n)) →
               (n : Nat) → Φ n;
natInduction Φ φ0 φS =
  induction NatDesc Φ
            (\x. case x for x. lift NatDesc Nat Φ x → Φ (construct x) with
                    { inl u. \u'. φ0
                    ; inr n. \φn. φS n φn
                    });

plus : Nat → Nat → Nat ;
plus = natInduction (\n. Nat → Nat)
                    (\y. y)
                    (\x f y. succ (f y));

data List (A : Set) : Set :=
  | nil  :
  | cons : A List
  ;

listInduction : (A : Set) →
                (Φ : List A → Set 2) →
                (Φ (nil A)) →
                ((a : A) → (l : List A) → Φ l → Φ (cons A a l)) →
                (l : List A) → Φ l;
listInduction A Φ pnil pcons =
  induction (ListDesc A) Φ
    (\x. case x for x. lift (ListDesc A) (List A) Φ x → Φ (construct x) with
            { inl u. λu'. pnil
            ; inr p. λih. pcons (fst p) (snd p) (snd ih)
            });
