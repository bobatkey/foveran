sem : Desc → Set → Set ;
sem = elimD (λx. Set → Set)
            (λA X. A)
            (λX. X)
            (λF G semF semG X. semF X × semG X)
            (λF G semF semG X. semF X + semG X);

lift : (D : Desc) →
       (α : Set) →
       (Φ : α → Set 2) →
       sem D α →
       Set 2 ;
lift D α Φ = elimD (\D. sem D α → Set 2)
                   (\A x. Unit)
                   (\x. Φ x)
                   (\F G f g x. f (fst x) × g (snd x))
                   (\F G f g x. case x for d. Set 2 with
                                   { inl y. f y
                                   ; inr z. g z
                                   })
                   D;

data Nat : Set :=
  | zero :
  | succ : Nat
  ;

natInduction : (Φ : Nat → Set 2) →
               (Φ zero) →
               ((n : Nat) → Φ n → Φ (succ n)) →
               (n : Nat) → Φ n;
natInduction Φ φ0 φS =
  induction NatDesc Φ
            (\x. case x for x. lift NatDesc Nat Φ x → Φ (construct NatDesc x) with
                    { inl u. \u'. φ0
                    ; inr n. \φn. φS n φn
                    });

deconstruct'' : (F : Desc) → µ F → sem F (µ F) ;
deconstruct'' F = induction F (\x. sem F (µ F)) (\x p. x);

-- FIXME: just define this in terms of induction (and automaticaly generate it from the data decl above)
caseNat : (A : Set 1) → A → (Nat → A) → Nat → A ;
caseNat A a f n = case deconstruct'' NatDesc n for x. A with
                    { inl u. a
                    ; inr n. f n
                    };

-- this should be auto-generated from the data decl
caseNat2 : (A : Set 1) → A → (Nat → A) → Nat → A ;
caseNat2 A a f = induction NatDesc (\x. A)
                           (\x p. case x for x. A with
                                     { inl u. a
                                     ; inr n. f n
                                     });

lt : Nat → Nat → Set;
lt = natInduction (λx. Nat → Set)
                  (λy. caseNat Set Empty (λy. Unit) y)
                  (λx f y. caseNat Set Empty f y);

data Term : Set :=
  | var  : Nat
  | app  : Term Term
  | lam  : Term
  ;

termInduction : (Φ : Term → Set 2) →
                ((n : Nat) → Φ (var n)) →
                ((t₁ t₂ : Term) → Φ t₁ → Φ t₂ → Φ (app t₁ t₂)) →
                ((t : Term) → Φ t → Φ (lam t)) →
                (t : Term) → Φ t ;
termInduction Φ φvar φapp φlam =
  induction TermDesc Φ
    (λx. case x for x. lift TermDesc Term Φ x → Φ (construct TermDesc x) with
            { inl n. λu. φvar n
            ; inr x. case x for x. lift TermDesc Term Φ (inr x) → Φ (construct TermDesc (inr x)) with
                        { inl t₁t₂. λφt₁t₂. φapp (fst t₁t₂) (snd t₁t₂) (fst φt₁t₂) (snd φt₁t₂)
                        ; inr t. λφt. φlam t φt
                        }
            });

goodTerm : Term → Nat → Set ;
goodTerm =
  termInduction (λt. Nat → Set)
    (λk n. lt k n)
    (λt₁ t₂ p₁ p₂ n. p₁ n × p₂ n)
    (λt p n. p (succ n));

-- just specify the good ones by a \hat{F}-algebra into some universe?

wsTerm : Nat → Set;
wsTerm n = (t : Term) × goodTerm t n;

wsVar : (n k : Nat) → lt k n → wsTerm n;
wsVar n k p = « var k, p » ;

wsApp : (n : Nat) → wsTerm n → wsTerm n → wsTerm n;
wsApp n t₁ t₂ = «app (fst t₁) (fst t₂), «snd t₁, snd t₂»»;

wsLam : (n : Nat) → wsTerm (succ n) → wsTerm n;
wsLam n t = «lam (fst t), snd t»;

wsTermInduction : (Φ : (n : Nat) → wsTerm n → Set 2) →
                  ((n k : Nat) → (p : lt k n) → Φ n (wsVar n k p)) →
                  ((n : Nat) → (t₁ t₂ : wsTerm n) → Φ n t₁ → Φ n t₂ → Φ n (wsApp n t₁ t₂)) →
                  ((n : Nat) → (t : wsTerm (succ n)) → Φ (succ n) t → Φ n (wsLam n t)) →
                  (n : Nat) → (t : wsTerm n) → Φ n t;
wsTermInduction Φ φvar φapp φlam n t =
  termInduction (λt. (n : Nat) → (p : goodTerm t n) → Φ n «t, p»)
    (λk n p. φvar n k p)
    (λt₁ t₂ p₁ p₂ n p. φapp n «t₁, fst p» «t₂, snd p» (p₁ n (fst p)) (p₂ n (snd p)))
    (λt p n g. φlam n «t,g» (p (succ n) g))
    (fst t)
    n
    (snd t);

-- what is the F that describes this inductive type?

F : (Nat → Set) → (Nat → Set) ;
F X n =   ((k : Nat) × lt k n)
        + X n × X n
        + X (succ n);

-- is it possible to auto-generate this from the goodTerm thing above?
-- Or autogenerate both of them?

constr : (n : Nat) → F wsTerm n → wsTerm n;
constr n x = case x for x. wsTerm n with
               { inl p. wsVar n (fst p) (snd p)
               ; inr x. case x for x. wsTerm n with
                           { inl p. wsApp n (fst p) (snd p)
                           ; inr p. wsLam n p
                           }
               };

{------------------------------------------------------------------------------}

relAlg : Desc → Set → Set 2;
relAlg D A = (x : sem D (µ D)) → lift D (µ D) (\x. A → Set) x → A → Set;

-- Doing the above generally
goodOnes : (D : Desc) →
           (A : Set) →
           relAlg D A →
           µ D →
           A →
           Set;
goodOnes D A k = induction D (\x. A → Set) k;

wf : (D : Desc) → (A : Set) → relAlg D A → A → Set ;
wf D A k a = (x : µ D) × goodOnes D A k x a;

{- constructWF : (D : Desc) → (A : Set) →
   -}           