toI : Desc -> IDesc Unit;
toI = elimD (λx. IDesc Unit)
            (λA. “K” A)
            (“IId” ⋄)
	    (λD₁ D₂ ID₁ ID₂. ID₁ “×” ID₂)
            (λD₁ D₂ ID₁ ID₂. “Σ” (Unit + Unit) (λb. case b for d. IDesc Unit with
                                                      { inl u. ID₁
				  	              ; inr u. ID₂
					              }));

lift2 : (D : Desc) ->
        (A : Set) ->
        sem D A ->
        IDesc A;
lift2 D A = elimD (λD. sem D A -> IDesc A)
                  (λA' x. “K” Unit)
                  (λx. “IId” x)
                  (λD₁ D₂ f g x. f (fst x) “×” g (snd x))
 		  (λD₁ D₂ f g x. case x for d. IDesc A with
		                    { inl y. f y
		 		    ; inr z. g z
				    })
                  D;

lift3 : (I : Set) ->
        (D : IDesc I) ->
        (A : I -> Set) ->
        semI[D, i. A i] ->
        IDesc ((i : I) × A i);
lift3 I D A = elimID I (λD. semI[D, i. A i] -> IDesc ((i : I) × A i))
                     (λi a. “IId” «i,a»)
                     (λA' a. “K” Unit)
                     (λD₁ D₂ lift₁ lift₂ p. lift₁ (fst p) “×” lift₂ (snd p))
                     (λB D liftD p. liftD (fst p) (snd p))
                     (λB D liftD f. “Π” B (λb. liftD b (f b)))
                     D;

lift4 : (I : Set) ->
        (D : IDesc I) ->
        (A : I -> Set) ->
        (P : (i : I) -> A i -> Set 2) ->
        semI[D, i. A i] ->
        Set 2;
lift4 I D A P x = semI[lift3 I D A x, p. P (fst p) (snd p)]


allI : (I  : Set) ->
       (D  : IDesc I) ->
       (A  : I -> Set) ->
       (P  : (i : I) -> A i -> Set 2) ->
       (p  : (i : I) -> (x : A i) -> P i x) ->
       (xs : semI[D, i. A i]) ->
       lift4 I D A P xs;
allI I D A P p = elimID I (λD. (xs : semI[D, i. A i]) -> lift4 I D A P xs)
                        (λx xs. p x xs)
                        (λA xs. ⋄)
                        (λD₁ D₂ all₁ all₂ x. «all₁ (fst x), all₂ (snd x)»)
                        (λB D all x. all (fst x) (snd x))
                        (λB D all x. λb. all b (x b))
                        D;

– this is all the bits I need to do induction on indexed data types!
– what about higher-Set universes? Do I need to beef up semI?

data Nat : Set :=
  | zero :
  | succ : Nat
  ;

caseNat :
  (Φ : Nat -> Set 2) ->
  (Φ zero) ->
  ((n : Nat) -> Φ (succ n)) ->
  (n : Nat) -> Φ n;
caseNat Φ φzero φsucc =
  induction NatDesc Φ
    (λx p. case x for x. Φ (construct x) with
             { inl u. φzero
             ; inr n. φsucc n
             });

vectorDesc : Nat -> IDesc Nat;
vectorDesc = caseNat (λn. IDesc Nat)
                     (    “K” Unit)
                     (λn. “K” Nat “×” “IId” n);

vector : Nat -> Set;
vector n = µI Nat vectorDesc n;

vnil : vector zero;
vnil = construct ⋄;

vcons : (n : Nat) -> Nat -> vector n -> vector (succ n);
vcons n a t = construct « a, t »;

{-
velim :
  (Φ : (n : Nat) -> vector n -> Set 2) ->
  (Φ zero vnil) ->
  ((n : Nat) -> (a : Nat) -> (t : vector n) -> Φ n t -> Φ (succ n) (vcons n a t)) ->
  (n : Nat) -> (v : vector n) -> Φ n v;
velim Φ φnil φcons =
  inductionI Nat vectorDesc Φ
    (caseNat (λn. (x : semI[vectorDesc n, n. vector n]) -> lift4 Nat (vectorDesc n) vector Φ x -> Φ n (construct x))
             (λx u. φnil)
             (λn x p. φcons n (fst x) (snd x) (snd p)));
-}