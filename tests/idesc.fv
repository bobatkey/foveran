toI : Desc → IDesc Unit;
toI = elimD (λx. IDesc Unit)
            (λA. “K” A)
            (“IId” ⋄)
	    (λD₁ D₂ ID₁ ID₂. ID₁ “×” ID₂)
            (λD₁ D₂ ID₁ ID₂. “Σ” (Unit + Unit) (λb. case b for d. IDesc Unit with
                                                      { inl u. ID₁
				  	              ; inr u. ID₂
					              }));

sem : Desc → Set → Set ;
sem = elimD (λx. Set → Set)
            (λA X. A)
            (λX. X)
            (λF G semF semG X. semF X × semG X)
            (λF G semF semG X. semF X + semG X);

lift : (D : Desc) →
       (α : Set) →
       (Φ : α → Set 2) →
       sem D α →
       Set 2 ;
lift D α Φ = elimD (\D. sem D α → Set 2)
                   (\A x. Unit)
                   (\x. Φ x)
                   (\F G f g x. f (fst x) × g (snd x))
                   (\F G f g x. case x for d. Set 2 with
                                   { inl y. f y
                                   ; inr z. g z
                                   })
                   D;

semI : (I : Set) → IDesc I → (I → Set 2) → Set 2;
semI I D X = elimID I (λD. Set 2)
                    (λi. X i)
                    (λA. A)
                    (λD₁ D₂ semD₁ semD₂. semD₁ × semD₂)
                    (λA D semD. (a : A) × semD a)
                    (λA D semD. (a : A) → semD a)
                    D;

lift2 : (D : Desc) →
        (A : Set) →
        sem D A →
        IDesc A;
lift2 D A = elimD (λD. sem D A → IDesc A)
                  (λA' x. “K” Unit)
                  (λx. “IId” x)
                  (λD₁ D₂ f g x. f (fst x) “×” g (snd x))
 		  (λD₁ D₂ f g x. case x for d. IDesc A with
		                    { inl y. f y
		 		    ; inr z. g z
				    })
                  D;

lift3 : (I : Set) →
        (D : IDesc I) →
        (A : I → Set) →
        semI I D (λi. A i) →
        IDesc ((i : I) × A i);
lift3 I D A = elimID I (λD. semI I D (λi. A i) → IDesc ((i : I) × A i))
                     (λi a. “IId” «i,a»)
                     (λA' a. “K” Unit)
                     (λD₁ D₂ lift₁ lift₂ p. lift₁ (fst p) “×” lift₂ (snd p))
                     (λB D liftD p. liftD (fst p) (snd p))
                     (λB D liftD f. “Π” B (λb. liftD b (f b)))
                     D;

lift4 : (I : Set) →
        (D : IDesc I) →
        (A : I → Set) →
        (P : (i : I) → A i → Set 2) →
        semI I D (λi. A i) →
        Set 2;
lift4 I D A P x = semI ((i : I) × A i) (lift3 I D A x) (λp. P (fst p) (snd p));


allI : (I  : Set) →
       (D  : IDesc I) →
       (A  : I → Set) →
       (P  : (i : I) → A i → Set 2) →
       (p  : (i : I) → (x : A i) → P i x) →
       (xs : semI I D (λi. A i)) →
       lift4 I D A P xs;
allI I D A P p = elimID I (λD. (xs : semI I D (λi. A i)) → lift4 I D A P xs)
                        (λx xs. p x xs)
                        (λA xs. ⋄)
                        (λD₁ D₂ all₁ all₂ x. «all₁ (fst x), all₂ (snd x)»)
                        (λB D all x. all (fst x) (snd x))
                        (λB D all x. λb. all b (x b))
                        D;

assume inductionI : (I : Set) →
                    (D : I → IDesc I) →
                    (P : (i : I) → µI I D i → Set 2) →
                    (k : (i : I) →
                         (x : semI I (D i) (λi. µI I D i)) →
                         lift4 I (D i) (µI I D) P x →
                         P i (construct x)) →
                    (i : I) →
                    (x : µI I D i) →
                    P i x;

– this is all the bits I need to do induction on indexed data types!
– what about higher-Set universes? Do I need to beef up semI?

data Nat : Set :=
  | zero :
  | succ : Nat
  ;

caseNat :
  (Φ : Nat → Set 2) →
  (Φ zero) →
  ((n : Nat) → Φ (succ n)) →
  (n : Nat) → Φ n;
caseNat Φ φzero φsucc =
  induction NatDesc Φ
    (λx p. case x for x. Φ (construct x) with
             { inl u. φzero
             ; inr n. φsucc n
             });

vectorDesc : Nat → IDesc Nat;
vectorDesc = caseNat (λn. IDesc Nat)
                     (    “K” Unit)
                     (λn. “K” Nat “×” “IId” n);

vector : Nat → Set;
vector n = µI Nat vectorDesc n;

vnil : vector zero;
vnil = construct ⋄;

vcons : (n : Nat) → Nat → vector n → vector (succ n);
vcons n a t = construct « a, t »;

velim :
  (Φ : (n : Nat) → vector n → Set 2) →
  (Φ zero vnil) →
  ((n : Nat) → (a : Nat) → (t : vector n) → Φ n t → Φ (succ n) (vcons n a t)) →
  (n : Nat) → (v : vector n) → Φ n v;
velim Φ φnil φcons =
  inductionI Nat vectorDesc Φ
    (caseNat (λn. (x : semI Nat (vectorDesc n) (λn. vector n)) → lift4 Nat (vectorDesc n) vector Φ x → Φ n (construct x))
             (λx u. φnil)
             (λn x p. φcons n (fst x) (snd x) (snd p)));