-- the generic elimination type for datatypes constructed by the 'data' declaration
elimtype :
  (I    : Set) ->
  (C    : Set) ->
  (body : I -> C -> IDesc I) ->
  (P    : (i : I) -> ÂµI I (Î»i. â€œÎ£â€ C (body i)) i -> Set 2) ->
  (i    : I) ->
  (c    : C) ->
  Set 2
elimtype I C body P =
  Î»i c.
    (z : semI[body i c, i. ÂµI I (Î»i. â€œÎ£â€ C (body i)) i]) ->
    liftI I (body i c) (Î»i. ÂµI I (Î»i. â€œÎ£â€ C (body i)) i) P z ->
    P i (construct Â«c,zÂ»)

--------------------------------------------------------------------------------
data Code : Set where
  param : Code
  rec   : Code
  pair  : Code -> Code -> Code
  sum   : Code -> Code -> Code
  unit  : Code

â€“ These should all be generated automatically
param : Code
param = construct Â«inl (), reflÂ»

rec : Code
rec = construct Â«inr (inl ()), reflÂ»

pair : Code -> Code -> Code
pair câ‚ câ‚‚ = construct Â«inr (inr (inl ())), câ‚, câ‚‚, reflÂ»

sum : Code -> Code -> Code
sum câ‚ câ‚‚ = construct Â«inr (inr (inr (inl ()))), câ‚, câ‚‚, reflÂ»

unit : Code
unit = construct Â«inr (inr (inr (inr ()))), reflÂ»

--------------------------------------------------------------------------------
Code:constructors : Set
Code:constructors = Unit + Unit + Unit + Unit + Unit

Code:body : Code:constructors -> IDesc Unit
Code:body = Î»d.
             case d for x. IDesc ðŸ™ with
               { inl a. â€œKâ€ (() â‰¡ ())
               ; inr b.
                    case b for x. IDesc ðŸ™ with
                      { inl a. â€œKâ€ (() â‰¡ ())
                      ; inr b0.
                           case b0 for x. IDesc ðŸ™ with
                             { inl a. â€œIIdâ€ () â€œÃ—â€ â€œIIdâ€ () â€œÃ—â€ â€œKâ€ (() â‰¡ ())
                             ; inr b1.
                                  case b1 for x. IDesc ðŸ™ with
                                    { inl a. â€œIIdâ€ () â€œÃ—â€ â€œIIdâ€ () â€œÃ—â€ â€œKâ€ (() â‰¡ ())
                                    ; inr b2. â€œKâ€ (() â‰¡ ())
                                    }
                             }
                      }
               }

Code:elimtype : (Code -> Set 2) -> Code:constructors -> Set 2
Code:elimtype P c = elimtype Unit Code:constructors (Î»_. Code:body) (Î»_. P) () c

-- an eliminator for Codes
-- this should be generated automatically
elimCode : (P : Code -> Set 2) ->
           P param ->
           P rec ->
           ((câ‚ câ‚‚ : Code) -> P câ‚ -> P câ‚‚ -> P (pair câ‚ câ‚‚)) ->
           ((câ‚ câ‚‚ : Code) -> P câ‚ -> P câ‚‚ -> P (sum câ‚ câ‚‚)) ->
           P unit ->
           (c : Code) -> P c
elimCode P Pparam Prec Ppair Psum Punit =
  inductionI Unit Code:code (Î»_. P)
    (Î»_ Â«c,dÂ».
      case c for c. Code:elimtype P c with
        { inl _. Î»z _. rewriteBy z then Pparam
        ; inr c.
          case c for c. Code:elimtype P (inr c) with
            { inl _. Î»z _. rewriteBy z then Prec
            ; inr c.
              case c for c. Code:elimtype P (inr (inr c)) with
                { inl _. Î»Â«câ‚,câ‚‚, eqÂ» Â«dâ‚,dâ‚‚,_Â». rewriteBy eq then Ppair câ‚ câ‚‚ dâ‚ dâ‚‚
                ; inr c.
                  case c for c. Code:elimtype P (inr (inr (inr c))) with
                    { inl _. Î»Â«câ‚,câ‚‚,eqÂ» Â«dâ‚,dâ‚‚,_Â». rewriteBy eq then Psum câ‚ câ‚‚ dâ‚ dâ‚‚
                    ; inr _. Î»z _. rewriteBy z then Punit
                    }
                }
            }
        } d)
    ()

toDesc : Code -> Set -> Unit -> IDesc Unit
toDesc C A _ =
  elimCode (Î»_. IDesc Unit)
    (â€œKâ€ A)
    (â€œIIdâ€ ())
    (Î»Câ‚ Câ‚‚ Dâ‚ Dâ‚‚. Dâ‚ â€œÃ—â€ Dâ‚‚)
    (Î»Câ‚ câ‚‚ Dâ‚ Dâ‚‚. â€œÎ£â€ (Unit + Unit) (Î»c. case c for c. IDesc Unit with { inl _. Dâ‚; inr _. Dâ‚‚ }))
    (â€œKâ€ Unit)
    C

{-
-- What I want to be able to write:
toDesc2 : Code -> Set -> Unit -> IDesc Unit
toDesc2 C A _ =
  eliminate C with
    param.      â€œKâ€ A
    rec.        â€œIIdâ€ ()
    pair Câ‚ Câ‚‚. recurse Câ‚ â€œÃ—â€ recurse Câ‚‚
    sum Câ‚ Câ‚‚.  â€œÎ£â€ (Unit + Unit) (Î»c. case c with { inl _. recurse Câ‚; inr _. recurse Câ‚‚ })
    unit.       â€œKâ€ ()
-}

reify : (C : Code) ->
        (A : Set) ->
        Set
reify C A = ÂµI Unit (toDesc C A) ()

mapC : (C : Code) ->
       (A B : Set) ->
       (f : A -> B) ->
       (X : Unit -> Set 2) ->
       semI[toDesc C A (), u. X u] ->
       semI[toDesc C B (), u. X u]
mapC C A B f X =
  elimCode (Î»C. semI[toDesc C A (), u. X u] -> semI[toDesc C B (), u. X u])
    f
    (Î»x. x)
    (Î»Câ‚ Câ‚‚ fâ‚ fâ‚‚ Â«aâ‚,aâ‚‚Â». Â«fâ‚ aâ‚, fâ‚‚ aâ‚‚Â»)
    (Î»Câ‚ Câ‚‚ fâ‚ fâ‚‚ Â«c,aÂ».
      case c for c. semI[case c for c. IDesc Unit with {inl _.toDesc Câ‚ A ();inr _.toDesc Câ‚‚ A ()}, u. X u] ->
                    semI[toDesc (sum Câ‚ Câ‚‚) B (), u. X u] with
        { inl _. Î»aâ‚. Â«inl (), fâ‚ aâ‚Â»
        ; inr _. Î»aâ‚‚. Â«inr (), fâ‚‚ aâ‚‚Â»
        } a)
    (Î»x. x)
    C

drop : (I : Set) â†’
       (D : I â†’ IDesc I) â†’
       (A : I â†’ Set) â†’
       (i : I) â†’
       (x : semI[D i, i. ÂµI I D i]) â†’
       liftI I (D i) (Î»i. ÂµI I D i) (Î»i x. A i) x â†’
       semI[D i, i. A i]
drop I D A i =
  elimID I
    (Î»D'. (x : semI[D', i. ÂµI I D i]) â†’
          liftI I D' (Î»i. ÂµI I D i) (Î»i x. A i) x â†’
          semI[D', i. A i])
    (Î»i x a. a)
    (Î»X x u. x)
    (Î»Dâ‚ Dâ‚‚ dropâ‚ dropâ‚‚ x a.
      Â«dropâ‚ (fst x) (fst a), dropâ‚‚ (snd x) (snd a)Â»)
    (Î»X D drop x a. Â«fst x, drop (fst x) (snd x) aÂ»)
    (Î»X D drop f a. Î»x. drop x (f x) (a x))
    (D i)

-- Set-level catamorphisms
icata : (I : Set) â†’
        (D : I â†’ IDesc I) â†’
        (A : I â†’ Set) â†’
        ((i : I) â†’ semI[D i, i. A i] â†’ A i) â†’
        (i : I) â†’ ÂµI I D i â†’ A i
icata I D A k =
  inductionI I D
    (Î»i x. A i)
    (Î»i x Ï†. k i (drop I D A i x Ï†))

â€“ generic map for all codes
map : (C : Code) ->
      (A B : Set) ->
      (f : A -> B) ->
      reify C A -> reify C B
map C A B f =
  icata Unit (toDesc C A) (Î»_. reify C B)
    (Î»_ x. construct (mapC C A B f (Î»_. reify C B) x))
    ()

--------------------------------------------------------------------------------
â€“ A example with lists
listcode : Code
listcode = sum unit (pair param rec)

list : Set -> Set
list A = reify listcode A

nil : (A : Set) -> list A
nil A = construct Â«inl (), ()Â»

cons : (A : Set) -> A -> list A -> list A
cons A a l = construct Â«inr (), a, lÂ»

â€“ let's make a list and apply map to it...
assume A : Set
assume a : A
assume b : A
assume B : Set
assume f : A -> B

l : list A
l = cons A a (cons A b (nil A))

normalise map listcode A B f l

;