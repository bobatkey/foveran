bool : Set;
bool = Unit + Unit;

true : bool;
true = inl ⋄;

false : bool;
false = inr ⋄;

or : bool → bool → bool;
or b₁ = case b₁ for b₁. bool → bool with
          { inl u. λb₂. true
          ; inr u. λb₂. b₂
          };

{-
or' : bool → bool → bool;
or' b₁ b₂ = case b₁ for b₁. bool with
              { inl u → true
              ; inr u → b₂
              };

equal : (A : Set) → A → A → Set 1;
equal A a₁ a₂ = (F : A → Set) → F a₁ → F a₂;

or-equal : equal (bool → bool) (or true) (or' true);
or-equal F p = p;
-}

and : bool → bool → bool;
and b₁ = case b₁ for b₁. bool → bool with
           { inl u. λb₂. b₂
           ; inr u. λb₂. false
           };

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
alphabet : Set;
alphabet = Unit + Unit;

a : alphabet;
a = inl ();

b : alphabet;
b = inr ();

symbol-eq : alphabet → alphabet → bool;
symbol-eq s₁ s₂ =
  case s₁ for s₁. bool with
    { inl u. case s₂ for s₂. bool with
                { inl u. true
                ; inr u. false
                }
    ; inr u. case s₂ for s₂. bool with
                { inl u. false
                ; inr u. true
                }
    };

data regexp : Set :=
  | eps  :
  | emp  :
  | alt  : regexp regexp
  | seq  : regexp regexp
  | star : regexp
  | tok  : alphabet
  ;

– goodness me...
regexpInduction : (Φ : regexp → Set 2) →
                  (Φ eps) →
                  (Φ emp) →
                  ((r₁ r₂ : regexp) → Φ r₁ → Φ r₂ → Φ (alt r₁ r₂)) →
                  ((r₁ r₂ : regexp) → Φ r₁ → Φ r₂ → Φ (seq r₁ r₂)) →
                  ((r : regexp) → Φ r → Φ (star r)) →
                  ((s : alphabet) → Φ (tok s)) →
                  (r : regexp) → Φ r;
regexpInduction Φ φeps φemp φalt φseq φstar φtok =
  induction regexpDesc Φ
  (λr. case r for r. lift regexpDesc regexp Φ r →
                      Φ (construct r) with
          { inl u. λu'. φeps
          ; inr r.
             case r for r. lift regexpDesc regexp Φ (inr r) →
                           Φ (construct (inr r)) with
               { inl u. λu'. φemp
               ; inr r.
                  case r for r. lift regexpDesc regexp Φ (inr (inr r)) →
                                Φ (construct (inr (inr r))) with
                    { inl p. λφ. φalt (fst p) (snd p) (fst φ) (snd φ)
                    ; inr r.
                       case r for r. lift regexpDesc regexp Φ (inr (inr (inr r))) →
                                     Φ (construct (inr (inr (inr r)))) with
                         { inl p. λφ. φseq (fst p) (snd p) (fst φ) (snd φ)
                         ; inr r.
                            case r for r. lift regexpDesc regexp Φ (inr (inr (inr (inr r)))) →
                                          Φ (construct (inr (inr (inr (inr r))))) with
                              { inl r. λφ. φstar r φ
                              ; inr s. λu. φtok s
                              }
                         }
                    }
               }
           });

acceptsEmpty : regexp → bool;
acceptsEmpty =
  regexpInduction (λr. bool)
                  (true)
                  (false)
                  (λr₁ r₂ accEmpty₁ accEmpty₂. or  accEmpty₁ accEmpty₂)
                  (λr₁ r₂ accEmpty₁ accEmpty₂. and accEmpty₁ accEmpty₂)
                  (λr accEmpty. true)
                  (λs. false);

step : regexp → alphabet → regexp;
step r s =
  regexpInduction (λr. regexp)
                  (emp)
                  (emp)
                  (λr₁ r₂ step₁ step₂. alt step₁ step₂)
                  (λr₁ r₂ step₁ step₂.
                      case acceptsEmpty r₁ for b. regexp with
                        { inl u. alt (seq step₁ r₂) step₂
			; inr u. seq step₁ r₂
                        })
                  (λr step. seq step (star r))
                  (λs'. case symbol-eq s s' for b. regexp with
                           { inl u. eps
                           ; inr u. emp
                           })
                  r;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
data List (α : Set) : Set :=
  | nil  :
  | cons : α List
  ;

listInduction : (A : Set) →
                (Φ : List A → Set 2) →
                (Φ (nil A)) →
                ((a : A) → (l : List A) → Φ l → Φ (cons A a l)) →
                (l : List A) → Φ l;
listInduction A Φ pnil pcons =
  induction (ListDesc A) Φ
    (\x. case x for x. lift (ListDesc A) (List A) Φ x → Φ (construct x) with
            { inl u. λu'. pnil
            ; inr p. λih. pcons (fst p) (snd p) (snd ih)
            });

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
match : List alphabet → regexp → bool;
match =
  listInduction alphabet (λl. regexp → bool)
    (λr. acceptsEmpty r)
    (λa rest f r. f (step r a));

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
test : regexp;
test = seq (star (alt (tok a) (tok b))) (tok a); – wouldn't it be great if there was support for infix syntax?

input1 : List alphabet;
input1 = cons alphabet a (cons alphabet b (cons alphabet a (nil alphabet)));

input2 : List alphabet;
input2 = cons alphabet a (cons alphabet b (nil alphabet));

test1 : match input1 test ≡ true;
test1 = refl;

test2 : match input2 test ≡ false;
test2 = refl;
