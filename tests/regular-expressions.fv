bool : Set;
bool = Unit + Unit;

true : bool;
true = inl ⋄;

false : bool;
false = inr ⋄;

or : bool -> bool -> bool;
or b1 = case b1 with
          { inl u. \b2. true
          ; inr u. \b2. b2
          };

and : bool -> bool -> bool;
and b1 = case b1 with { inl u. \b2. b2; inr u. \b2. false };

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
symbol : Set;
symbol = Unit + Unit;

a : symbol;
a = inl ();

b : symbol;
b = inr ();

symbol-eq : symbol -> symbol -> bool;
symbol-eq s1 s2 =
  case s1 with
    { inl u. case s2 with { inl u. true; inr u. false }
    ; inr u. case s2 with { inl u. false; inr u. true }
    };

--------------------------------------------------------------------------------
data regexp : Set where
  `eps  : regexp
  `emp  : regexp
  `alt  : regexp -> regexp -> regexp
  `seq  : regexp -> regexp -> regexp
  `star : regexp -> regexp
  `tok  : symbol -> regexp

regexpInduction :
  (P : regexp -> Set 2) ->
  (P `eps) ->
  (P `emp) ->
  ((r1 r2 : regexp) -> P r1 -> P r2 -> P (`alt r1 r2)) ->
  ((r1 r2 : regexp) -> P r1 -> P r2 -> P (`seq r1 r2)) ->
  ((r : regexp) -> P r -> P (`star r)) ->
  ((s : symbol) -> P (`tok s)) ->
  (r : regexp) -> P r
regexpInduction P peps pemp palt pseq pstar ptok r =
  eliminate r with _ «c,d» rec.
    generalise rec then
    generalise d then
    case c with
      { inl _. \eq _. rewriteBy eq then peps
      ; inr c.
        case c with
          { inl _. \eq _. rewriteBy eq then pemp
          ; inr c. 
            case c with
              { inl _. \«r1,r2,eq» «p1,p2,_». rewriteBy eq then palt r1 r2 p1 p2
              ; inr c.
                case c with
                  { inl _. \«r1,r2,eq» «p1,p2,_». rewriteBy eq then pseq r1 r2 p1 p2
                  ; inr c .
                    case c with
                      { inl _. \«r,eq» «p,_». rewriteBy eq then pstar r p
                      ; inr _. \«s,eq» _. rewriteBy eq then ptok s
                      }
                  }
              }
          }
      };

acceptsEmpty : regexp -> bool;
acceptsEmpty =
  regexpInduction (\r. bool)
                  (true)
                  (false)
                  (\r1 r2 accEmpty1 accEmpty2. or  accEmpty1 accEmpty2)
                  (\r1 r2 accEmpty1 accEmpty2. and accEmpty1 accEmpty2)
                  (\r accEmpty. true)
                  (\s. false);

step : regexp -> symbol -> regexp;
step r s =
  regexpInduction (\r. regexp)
                  `emp
                  `emp
                  (\r1 r2 step1 step2. `alt step1 step2)
                  (\r1 r2 step1 step2.
                      case acceptsEmpty r1 with
                        { inl u. `alt (`seq step1 r2) step2
			; inr u. `seq step1 r2
                        })
                  (\r step. `seq step (`star r))
                  (\s'. case symbol-eq s s' with
                           { inl u. `eps
                           ; inr u. `emp
                           })
                  r;

--------------------------------------------------------------------------------
data List (A : Set) : Set where
  `nil  : List A
  `cons : A -> List A -> List A

listInduction : (A : Set) ->
                (P : List A -> Set 2) ->
                (P `nil) ->
                ((a : A) -> (l : List A) -> P l -> P (`cons a l)) ->
                (l : List A) -> P l;
listInduction A P pnil pcons l =
  eliminate l with _ «c,d» r.
    generalise r then
    generalise d then
    case c with
      { inl _. \eq _. rewriteBy eq then pnil
      ; inr _. \«a,l,eq» «r,_». rewriteBy eq then pcons a l r
      }

--------------------------------------------------------------------------------
match : List symbol -> regexp -> bool;
match =
  listInduction symbol (\l. regexp -> bool)
    (\r. acceptsEmpty r)
    (\a rest f r. f (step r a));

--------------------------------------------------------------------------------
test : regexp;
test = `seq (`star (`alt (`tok a) (`tok b))) (`tok a); – wouldn't it be great if there was support for infix syntax?

input1 : List symbol;
input1 = `cons a (`cons b (`cons a `nil));

input2 : List symbol;
input2 = `cons a (`cons b `nil);

test1 : match input1 test == true;
test1 = refl;

test2 : match input2 test == false;
test2 = refl;
