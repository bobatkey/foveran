– FIXME: make this not Set 2 (need to fix Value.hs too)
semI : (I : Set) → IDesc I → (I → Set 2) → Set 2;
semI I D X = elimID I (λD. Set 2)
                    (λi. X i)
                    (λA. A)
                    (λD₁ D₂ semD₁ semD₂. semD₁ × semD₂)
                    (λA D semD. (a : A) × semD a)
                    (λA D semD. (a : A) → semD a)
                    D;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
data Nat : Set :=
  | zero :
  | succ : Nat
  ;

natInduction : (Φ : Nat → Set 2) →
               (Φ zero) →
               ((n : Nat) → Φ n → Φ (succ n)) →
               (n : Nat) → Φ n;
natInduction Φ φ0 φS =
  induction NatDesc Φ
            (\x. case x for x. lift NatDesc Nat Φ x → Φ (construct x) with
                    { inl u. \u'. φ0
                    ; inr n. \φn. φS n φn
                    });

natCase : (A : Nat → Set 2) → A zero → ((n : Nat) → A (succ n)) → (n : Nat) → A n;
natCase A a f = induction NatDesc A
                          (λx p. case x for x. A (construct x) with
                                    { inl u. a
                                    ; inr n. f n
                                    });

one : Nat;
one = succ zero;

two : Nat;
two = succ one;

three : Nat;
three = succ two;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
Bool : Set;
Bool = Unit + Unit;

{-
– the following should all be generated from:

data vec (α : Set) : Nat → Set where
  vnil  : vec α zero
  vcons : (n : Nat) → α → vec α n → vec α (succ n);

in general:

data vec [parameters] : IndexType → Set where
  cname : [arg] → vec [params] [index-value]

where arg is (x : <some-set>)
which either ends in vec params index-value, or something else
-}

body : Set → Nat → Bool → IDesc Nat;
body α n b =
  case b for b. IDesc Nat with
    { inl u. “K” (zero ≡ n)
    ; inr u. “Σ” Nat (λn'. “Σ” α (λa. “IId” n' “×” “K” (succ n' ≡ n)))
    };

vecDesc : Set → Nat → IDesc Nat;
vecDesc α n = “Σ” Bool (body α n);

vec : Set → Nat → Set;
vec α = µI Nat (vecDesc α);

vnil : (α : Set) → vec α zero;
vnil α = construct «inl (), refl»;

vcons : (α : Set) → (n : Nat) → α → vec α n → vec α (succ n);
vcons α n a xs = construct «inr (), «n, «a, «xs, refl»»»»;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
vecElim :
  (α : Set) →
  (Φ : (n : Nat) → vec α n → Set 2) →
  Φ zero (vnil α) →
  ((n : Nat) → (a : α) → (xs : vec α n) → Φ n xs → Φ (succ n) (vcons α n a xs)) →
  (n : Nat) →
  (xs : vec α n) →
  Φ n xs;
vecElim α Φ φnil φcons =
  inductionI Nat (vecDesc α) Φ
    (λn x.
      case fst x for b. (z : semI Nat (body α n b) (λn. vec α n)) →
                        liftI Nat (body α n b) (λn. vec α n) Φ z →
                        Φ n (construct «b,z») with
        { inl u. λz u.
            elimEq z
              for n' p. Φ n' (construct «inl (), p»)
              with φnil
        ; inr u. λz φ.
            elimEq snd (snd (snd z))
              for n p. Φ n (construct «inr (), «fst z, «fst (snd z), «fst (snd (snd z)), p»»»»)
              with (φcons (fst z) (fst (snd z)) (fst (snd (snd z))) (fst φ))
        } (snd x));

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
add : Nat → Nat → Nat ;
add n₁ n₂ = natInduction (λx. Nat) n₂ (λn. succ) n₁;

vecappend :
  (α : Set) →
  (n₁ n₂ : Nat) →
  vec α n₁ →
  vec α n₂ →
  vec α (add n₁ n₂);
vecappend α n₁ n₂ xs ys =
  vecElim α (λn xs. vec α (add n n₂))
    ys
    (λn a xs xys. vcons α (add n n₂) a xys)
    n₁
    xs;

-- vecreverse :
--   (α : Set) →
--   (n : Nat) →
--   vec α n → 

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
assume A : Set;
assume a : A;
assume b : A;

v : vec A two;
v = vcons A one a (vcons A zero b (vnil A));

normalise vecappend A two two v v;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
succ≢zero : (n : Nat) → succ n ≡ zero → Empty;
succ≢zero n eq =
  elimEq eq for n p. natCase (λn. Set) Empty (λu. Unit) n with ();

symm :
  (α : Set) →
  (a₁ a₂ : α) →
  a₁ ≡ a₂ →
  a₂ ≡ a₁;
symm α a₁ a₂ eq =
  elimEq eq for a p. a ≡ a₁ with refl;

succ-inj : (n₁ n₂ : Nat) → succ n₁ ≡ succ n₂ → n₁ ≡ n₂;
succ-inj n₁ n₂ eq =
  elimEq symm Nat (succ n₁) (succ n₂) eq
    for n p. natCase (λn. Set) Empty (λn. n ≡ n₂) n
    with refl;

is-vnil : (α : Set) → (xs : vec α zero) → xs ≡ vnil α;
is-vnil α xs =
  vecElim α (λn xs. n ≡ zero → xs ≡ vnil α)
    (λeq. refl)
    (λn a xs φ eq. elimEmpty (vcons α n a xs ≡ vnil α) (succ≢zero n eq))
    zero
    xs
    refl;

elim-veczero :
  (α : Set) →
  (Φ : (n : Nat) → vec α n → Set) →
  Φ zero (vnil α) →
  (xs : vec α zero) →
  Φ zero xs;
elim-veczero α Φ φnil xs =
  vecElim α (λn xs. n ≡ zero → Φ n xs)
    (λeq. φnil)
    (λn a xs φ eq. elimEmpty (Φ (succ n) (vcons α n a xs)) (succ≢zero n eq))
    zero
    xs
    refl;

elim-veczero2 :
  (α : Set) →
  (Φ : vec α zero → Set) →
  Φ (vnil α) →
  (xs : vec α zero) →
  Φ xs;
elim-veczero2 α Φ φnil xs =
  vecElim α (λn xs. (xs' : vec α zero) → n ≡ zero → xs ≡ xs' → Φ xs')
    (λxs' eq₁ eq₂. elimEq eq₂ for x p. Φ x with φnil)
    (λn a xs φ xs' eq₁ eq₂. elimEmpty (Φ xs') (succ≢zero n eq₁))
    zero
    xs
    xs
    refl
    refl;

is-vcons : (α : Set) →
           (n : Nat) →
           (xs : vec α (succ n)) →
           (a : α) × (xs' : vec α n) × xs ≡ vcons α n a xs';
is-vcons α n xs =
  vecElim α (λn' xs. succ n ≡ n' → (a : α) × (xs' : vec α n) × xs ≡ vcons α n a xs')
    (λeq. elimEmpty ((a : α) × (xs' : vec α n) × vnil α ≡ vcons α n a xs') (succ≢zero n eq))
    (λn' a xs' φ eq. 
      elimEq symm Nat n n' (succ-inj n n' eq)
         for n'' p. (a' : α) × (xs'' : vec α n'') × vcons α n' a xs' ≡ vcons α n'' a' xs''
         with «a, «xs', refl»»)
    (succ n)
    xs
    refl;

elim-vecsucc :
  (α : Set) →
  (Φ : (n : Nat) → vec α (succ n) → Set) →
  ((n : Nat) → (a : α) → (xs : vec α n) → Φ n (vcons α n a xs)) →
  (n : Nat) → (xs : vec α (succ n)) → Φ n xs;
elim-vecsucc α Φ φcons n xs =
  vecElim α (λn xs. (n' : Nat) → (xs' : vec α (succ n')) → n ≡ succ n' → xs ≡ xs' → Φ n' xs')
    (λn' xs' eq₁ eq₂. elimEmpty (Φ n' xs') (succ≢zero n' (symm Nat zero (succ n') eq₁)))
    (λn a xs φ n' xs' eq₁.
      elimEq succ-inj n n' eq₁
         for n' p. (xs' : vec α (succ n')) → vcons α n a xs ≡ xs' → Φ n' xs'
         with (λxs' eq₂. elimEq eq₂ for xs' p. Φ n xs'
                           with (φcons n a xs))
       xs')
    (succ n)
    xs
    n
    xs
    refl
    refl;

is-vcons2 :
  (α : Set) →
  (n : Nat) →
  (xs : vec α (succ n)) →
  (a : α) × (xs' : vec α n) × xs ≡ vcons α n a xs';
is-vcons2 α =
  elim-vecsucc α
    (λn xs. (a : α) × (xs' : vec α n) × xs ≡ vcons α n a xs')
    (λn a xs. «a, «xs, refl»»);
