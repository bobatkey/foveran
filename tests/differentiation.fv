map : (F : Desc) → (α β : Set) → (α → β) → sem F α → sem F β ;
map F α β f = elimD (\F. sem F α → sem F β)
                    (\A x. x)
                    (\x. f x)
                    (\d1 d2 g h p. «g (fst p), h (snd p)»)
	            (\d1 d2 g h s. case s for x. sem (d1 “+” d2) β with
                                      { inl x. inl (g x)
	   			      ; inr x. inr (h x)
				      })
                    F ;

-- Lexer doesn't like ‘↑’
-- ↑ : Set → Desc ;
-- ↑ A = “K” A ;

data List (A : Set) : Set :=
  | nil  :
  | cons : A List
  ;

listInduction : (A : Set) →
                (Φ : List A → Set 2) →
                (Φ (nil A)) →
                ((a : A) → (l : List A) → Φ l → Φ (cons A a l)) →
                (l : List A) → Φ l;
listInduction A Φ pnil pcons =
  induction (ListDesc A) Φ
    (\x. case x for x. lift (ListDesc A) (List A) Φ x → Φ (construct x) with
            { inl u. λu'. pnil
            ; inr p. λih. pcons (fst p) (snd p) (snd ih)
            });

data Tree : Set :=
  | leaf      :
  | twoNode   : Tree Tree
  | threeNode : Tree Tree Tree
  ;

{-
foldList : (α β : Set) → (α → β → β) → β → List α → β ;
foldList α β f b = fold (ListDesc α) β (\x → case x for a. β with
                                               { inl y → b
                                               ; inr k → f (fst k) (snd k)
				               }) ;

append : (α : Set) → List α → List α → List α ;
append α = foldList α (List α → List α)
                    (\a f y → cons α a (f y))
                    (\x → x) ;
-}

∂ : Desc → Desc ;
∂ = elimD (\x. Desc)
          (\A. “K” 𝟘)
          (“K” 𝟙)
          (\F G ∂F ∂G. (∂F “×” G) “+” (F “×” ∂G))
          (\F G ∂F ∂G. ∂F “+” ∂G) ;

up : (F : Desc) → (X : Set) → X → sem (∂ F) X → sem F X ;
up F X x = elimD (\F. sem (∂ F) X → sem F X)
                 (\A x. elimEmpty A x)
                 (\x'. x)
                 (\F G f g s. case s for a. sem (F “×” G) X with
                                 { inl s. «f (fst s), snd s»
                                 ; inr s. «fst s, g (snd s)»
	 		         })
                 (\F G f g s. case s for a. sem (F “+” G) X with
		                 { inl s1. inl (f s1)
		                 ; inr s2. inr (g s2)
				 })
                 F ;

Div : Desc → Desc ;
Div F = “Id” “×” ∂ F ;

down : (F : Desc) → (X : Set) → sem F X → sem F (sem (Div F) X) ;
down = \F X. elimD (\F. sem F X → sem F (sem (Div F) X))
                    (\A x. x)
                    (\x. «x, ()»)
                    (\F G f g p.
                        « map F (sem (Div F) X) (sem (Div (F “×” G)) X)
                                (\p'. « fst p', inl « snd p', snd p »»)
                                (f (fst p))
                        , map G (sem (Div G) X) (sem (Div (F “×” G)) X)
                                (\p'. « fst p', inr « fst p, snd p' »»)
                                (g (snd p))
                        »)
                    (\F G downf downg s.
                        case s for a. sem (F “+” G) (sem (Div (F “+” G)) X) with
                          { inl f. inl (map F (sem (Div F) X) (sem (Div (F “+” G)) X)
                                             (\x. « fst x, inl (snd x) ») (downf f))
                          ; inr g. inr (map G (sem (Div G) X) (sem (Div (F “+” G)) X)
                                             (\x. « fst x, inr (snd x) ») (downg g))
			  })
                    F ;

Ctx : Desc → Set ;
Ctx F = List (sem (∂ F) (µ F)) ;

--context : Desc → Desc ;
--context = \F → ListDesc (sem (∂ F) (µ F)) ;

plug : (F : Desc) → Ctx F → µ F → µ F ;
plug F = listInduction (sem (∂ F) (µ F))
                       (λl. µ F → µ F)
                       (λx. x)
                       (λc l f x. construct (up F (µ F) (f x) c));
