map : (F : Desc) â†’ (Î± Î² : Set) â†’ (Î± â†’ Î²) â†’ sem F Î± â†’ sem F Î² ;
map F Î± Î² f = elimD (\F. sem F Î± â†’ sem F Î²)
                    (\A x. x)
                    (\x. f x)
                    (\d1 d2 g h p. Â«g (fst p), h (snd p)Â»)
	            (\d1 d2 g h s. case s for x. sem (d1 â€œ+â€ d2) Î² with
                                      { inl x. inl (g x)
	   			      ; inr x. inr (h x)
				      })
                    F ;

-- Lexer doesn't like â€˜â†‘â€™
-- â†‘ : Set â†’ Desc ;
-- â†‘ A = â€œKâ€ A ;

data List (A : Set) : Set :=
  | nil  :
  | cons : A List
  ;

listInduction : (A : Set) â†’
                (Î¦ : List A â†’ Set 2) â†’
                (Î¦ (nil A)) â†’
                ((a : A) â†’ (l : List A) â†’ Î¦ l â†’ Î¦ (cons A a l)) â†’
                (l : List A) â†’ Î¦ l;
listInduction A Î¦ pnil pcons =
  induction (ListDesc A) Î¦
    (\x. case x for x. lift (ListDesc A) (List A) Î¦ x â†’ Î¦ (construct x) with
            { inl u. Î»u'. pnil
            ; inr p. Î»ih. pcons (fst p) (snd p) (snd ih)
            });

data Tree : Set :=
  | leaf      :
  | twoNode   : Tree Tree
  | threeNode : Tree Tree Tree
  ;

{-
foldList : (Î± Î² : Set) â†’ (Î± â†’ Î² â†’ Î²) â†’ Î² â†’ List Î± â†’ Î² ;
foldList Î± Î² f b = fold (ListDesc Î±) Î² (\x â†’ case x for a. Î² with
                                               { inl y â†’ b
                                               ; inr k â†’ f (fst k) (snd k)
				               }) ;

append : (Î± : Set) â†’ List Î± â†’ List Î± â†’ List Î± ;
append Î± = foldList Î± (List Î± â†’ List Î±)
                    (\a f y â†’ cons Î± a (f y))
                    (\x â†’ x) ;
-}

âˆ‚ : Desc â†’ Desc ;
âˆ‚ = elimD (\x. Desc)
          (\A. â€œKâ€ ğŸ˜)
          (â€œKâ€ ğŸ™)
          (\F G âˆ‚F âˆ‚G. (âˆ‚F â€œÃ—â€ G) â€œ+â€ (F â€œÃ—â€ âˆ‚G))
          (\F G âˆ‚F âˆ‚G. âˆ‚F â€œ+â€ âˆ‚G) ;

up : (F : Desc) â†’ (X : Set) â†’ X â†’ sem (âˆ‚ F) X â†’ sem F X ;
up F X x = elimD (\F. sem (âˆ‚ F) X â†’ sem F X)
                 (\A x. elimEmpty A x)
                 (\x'. x)
                 (\F G f g s. case s for a. sem (F â€œÃ—â€ G) X with
                                 { inl s. Â«f (fst s), snd sÂ»
                                 ; inr s. Â«fst s, g (snd s)Â»
	 		         })
                 (\F G f g s. case s for a. sem (F â€œ+â€ G) X with
		                 { inl s1. inl (f s1)
		                 ; inr s2. inr (g s2)
				 })
                 F ;

Div : Desc â†’ Desc ;
Div F = â€œIdâ€ â€œÃ—â€ âˆ‚ F ;

down : (F : Desc) â†’ (X : Set) â†’ sem F X â†’ sem F (sem (Div F) X) ;
down = \F X. elimD (\F. sem F X â†’ sem F (sem (Div F) X))
                    (\A x. x)
                    (\x. Â«x, ()Â»)
                    (\F G f g p.
                        Â« map F (sem (Div F) X) (sem (Div (F â€œÃ—â€ G)) X)
                                (\p'. Â« fst p', inl Â« snd p', snd p Â»Â»)
                                (f (fst p))
                        , map G (sem (Div G) X) (sem (Div (F â€œÃ—â€ G)) X)
                                (\p'. Â« fst p', inr Â« fst p, snd p' Â»Â»)
                                (g (snd p))
                        Â»)
                    (\F G downf downg s.
                        case s for a. sem (F â€œ+â€ G) (sem (Div (F â€œ+â€ G)) X) with
                          { inl f. inl (map F (sem (Div F) X) (sem (Div (F â€œ+â€ G)) X)
                                             (\x. Â« fst x, inl (snd x) Â») (downf f))
                          ; inr g. inr (map G (sem (Div G) X) (sem (Div (F â€œ+â€ G)) X)
                                             (\x. Â« fst x, inr (snd x) Â») (downg g))
			  })
                    F ;

Ctx : Desc â†’ Set ;
Ctx F = List (sem (âˆ‚ F) (Âµ F)) ;

--context : Desc â†’ Desc ;
--context = \F â†’ ListDesc (sem (âˆ‚ F) (Âµ F)) ;

plug : (F : Desc) â†’ Ctx F â†’ Âµ F â†’ Âµ F ;
plug F = listInduction (sem (âˆ‚ F) (Âµ F))
                       (Î»l. Âµ F â†’ Âµ F)
                       (Î»x. x)
                       (Î»c l f x. construct (up F (Âµ F) (f x) c));
