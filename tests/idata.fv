semI : (I : Set) â†’ IDesc I â†’ (I â†’ Set 2) â†’ Set 2;
semI I D X = elimID I (Î»D. Set 2)
                    (Î»i. X i)
                    (Î»A. A)
                    (Î»Dâ‚ Dâ‚‚ semDâ‚ semDâ‚‚. semDâ‚ Ã— semDâ‚‚)
                    (Î»A D semD. (a : A) Ã— semD a)
                    (Î»A D semD. (a : A) â†’ semD a)
                    D;

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
data Nat : Set where
  { zero : Nat
  ; succ : Nat â†’ Nat
  };

normalise Nat;

zero : Nat;
zero = construct Â«inl (), reflÂ»; â€“ :zero

succ : Nat â†’ Nat;
succ n = construct Â«inr (), n, reflÂ»; â€“ :succ n

â€“ Somewhere, we store that 'succ' is a constructor, because it was generated by 'data' decl.
â€“ The conversion to locally nameless then knows that, and converts the application to a constructor application

â€“ The type checker then realises that the type will be pushed in, so
â€“ we can determine which constructor is meant. In this way, we can
â€“ overload constructors.

â€“ Need to make sure that constructor names cannot be shadowed

â€“ and we should add a check that we have got the right type. This will
â€“ be some kind of hint in the LocallyNameless syntax

Nat:body : Unit + Unit -> IDesc Unit;
Nat:body d = case d for x. IDesc ğŸ™ with
               { inl _. â€œKâ€ (() â‰¡ ())
               ; inr _. â€œIIdâ€ () â€œÃ—â€ â€œKâ€ (() â‰¡ ())
               };

elimtype :
  (I    : Set) â†’
  (C    : Set) â†’
  (body : I â†’ C â†’ IDesc I) â†’
  (P    : (i : I) â†’ ÂµI I (Î»i. â€œÎ£â€ C (body i)) i â†’ Set 2) â†’
  (i    : I) â†’
  (c    : C) â†’
  Set 2;
elimtype I C body P =
  Î»i c.
    (z : semI I (body i c) (Î»i. ÂµI I (Î»i. â€œÎ£â€ C (body i)) i)) â†’
    liftI I (body i c) (Î»i. ÂµI I (Î»i. â€œÎ£â€ C (body i)) i) P z â†’
    P i (construct Â«c,zÂ»);

Nat:elim :
  (P : Nat â†’ Set 2) â†’
  (P zero) â†’
  ((n : Nat) â†’ P n â†’ P (succ n)) â†’
  (n : Nat) â†’
  P n;
Nat:elim P pzero psucc =
  inductionI Unit Nat:code (Î»_. P)
    (Î»_ x. case fst x for b. elimtype Unit (Unit + Unit) (Î»_. Nat:body) (Î»_. P) () b with
      { inl _. Î»z _. rewriteBy z then pzero
      ; inr _. Î»z p. rewriteBy (snd z) then psucc (fst z) (fst p)
      } (snd x))
    ();

{-
introduce P pzero psucc n.
eliminate n with
  introduce _ Â«constructor, argumentsÂ».
  case constructor for c. (z : semI Unit (Nat:body c) (Î»_. Nat ())) â†’
                          liftI Unit (Nat:body c) (Î»_. Nat ()) (Î»_. P) z â†’
                          P (construct Â«c, argumentsÂ») with
    { inl _. introduce eq _.
      rewriteBy eq then pzero
    ; inr _. introduce Â«n, eqÂ» Â«p, _Â».
      rewriteBy eq then psucc n p
    } arguments

introduce P pzero psucc n.
eliminate n with
  zero.   pzero
  succ n. psucc n (recurse n)

introduce nâ‚ nâ‚‚.
eliminate[plus] nâ‚ with
  zero.   nâ‚‚
  succ n. succ (plus n)

introduce nâ‚.
eliminate[plus] nâ‚ with
  zero.   introduce nâ‚‚. nâ‚‚
  succ n. introduce nâ‚‚. succ (plus n nâ‚‚)

These last three look at the form of the datatype, and use it to
generate the code above. The name of the eliminator tells it how to
translate the recusive calls into references to the proof objects.

To do: deeper recursion, probably with the generic sub-term relation.

To do: elimination-with-a-motive-style enhancing of the inductive
premise and removal of cases that are impossible. Could implement this
with a "ElimEq"-style tactic that attempts to get rid of as many
equalities from the context as possible.

"introduce" should emit a warning if a function type has a name, but
we use a different name in the code.

How would "with" work? If you do something like
  with isZero n
then you either get back a proof that 'n' is zero, or a new number 'm'
and a proof that n = succ m. The plan then is to rewrite all the
hypotheses to include this new information. This could be done with a
new tactic.

-}

data List (A : Set) : Set where
  { nil  : List A
  ; cons : A â†’ List A â†’ List A
  };

data Vector (A : Set) : Nat â†’ Set where
  { vnil  : Vector A zero
  ; vcons : (n : Nat) â†’ A â†’ Vector A n â†’ Vector A (succ n)
  };

vnil : (A : Set) â†’ Vector A zero;
vnil A = construct Â«inl (), reflÂ»;

vcons : (A : Set) â†’ (n : Nat) â†’ A â†’ Vector A n â†’ Vector A (succ n);
vcons A n a xs = construct Â«inr (), n, a, xs, reflÂ»;

{-
Maybe:

local
  assume A : Set

  data List : Set where
    nil  : List
    cons : A â†’ List â†’ List
-}
â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
Vector:body : Set â†’ Nat â†’ Unit + Unit â†’ IDesc Nat;
Vector:body A n b =
  case b for b. IDesc Nat with
    { inl _. â€œKâ€ (zero â‰¡ n)
    ; inr _. â€œÎ£â€ Nat (Î»n'. â€œÎ£â€ A (Î»a. â€œIIdâ€ n' â€œÃ—â€ â€œKâ€(succ n' â‰¡ n)))
    };

Vector:elim :
  (A : Set) â†’
  (Î¦ : (n : Nat) â†’ Vector A n â†’ Set 2) â†’
  Î¦ zero (vnil A) â†’
  ((n : Nat) â†’ (a : A) â†’ (xs : Vector A n) â†’ Î¦ n xs â†’ Î¦ (succ n) (vcons A n a xs)) â†’
  (n : Nat) â†’
  (xs : Vector A n) â†’
  Î¦ n xs;
Vector:elim A Î¦ Ï†nil Ï†cons =
  inductionI Nat (Vector:code A) Î¦
    (Î»n x.
      case fst x for b. elimtype Nat (Unit + Unit) (Vector:body A) Î¦ n b with
        { inl _. Î»z _. rewriteBy z then Ï†nil
        ; inr _. Î»z Ï†. rewriteBy snd (snd (snd z)) then Ï†cons (fst z) (fst (snd z)) (fst (snd (snd z))) (fst Ï†)
        } (snd x));

       â€“; inr _. Î»Â«n', a, xs, eqÂ» Â«Ï†, _Â». rewriteBy eq then (Ï†cons n' a xs Ï†)
       â€“; inr Â«n', a, xs, eqÂ». Î»Â«Ï†, _Â». rewriteBy eq then (Ï†cons n' a xs Ï†)

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
data Emp : Set where { };

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
data regexp (A : Set) : Set where
  { eps  : regexp A
  ; emp  : regexp A
  ; alt  : regexp A â†’ regexp A â†’ regexp A
  ; seq  : regexp A â†’ regexp A â†’ regexp A
  ; star : regexp A â†’ regexp A
  ; tok  : A â†’ regexp A
  };

{-
data Fin : Nat â†’ Set where
  { fz : (n : Nat) â†’ Fin (succ n)
  ; fs : (n : Nat) â†’ Fin n â†’ Fin (succ n)
  };
-}
{-
{-

data Foo : Unit â†’ Set where
  { foo1 : Foo ()
  ; foo2 : Foo ()
  ; foo3 : Foo ()
  ; foo4 : Foo () â†’ Foo ()
  };
-}

{-
assume lt : Nat () â†’ Nat () â†’ Set;

data Acc : Nat () â†’ Set where
  { acc : (n : Nat ()) â†’ ((n' : Nat ()) â†’ lt n' n â†’ Acc n') â†’ Acc n
  };
-}

{-
data Acc2 (A : Set) (lt : A â†’ A â†’ Set) : A â†’ Set where
  { acc2 : (a : A) â†’ ((a' : A) â†’ lt a' a â†’ Acc2 A lt a') â†’ Acc2 A lt a
  };

assume acc2ty :
  (A : Set) â†’
  (lt : A â†’ A â†’ Set) â†’                       â€“ parameters

  (Î¦ : (a : A) â†’ Acc2 A lt a â†’ Set) â†’        â€“ predicate

  (a : A) â†’
  (f : (a' : A) â†’ lt a' a â†’ Acc2 A lt a') â†’  â€“ constructor arguments

  ((a' : A) â†’ (x : lt a' a) â†’ Î¦ a' (f a' x)) â†’ â€“ induction hypotheses

  Î¦ a (acc2 A lt a f);                            â€“ result
-}

{-
normalise acc2;

data Emp : Nat () â†’ Set where
  { };
-}

