semI : (I : Set) -> IDesc I -> (I -> Set 2) -> Set 2
semI I D X =
  elimID I (Î»D. Set 2)
    (Î»i. X i)
    (Î»A. A)
    (Î»Dâ‚ Dâ‚‚ semDâ‚ semDâ‚‚. semDâ‚ Ã— semDâ‚‚)
    (Î»A D semD. (a : A) Ã— semD a)
    (Î»A D semD. (a : A) -> semD a)
    D

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
data Nat : Set where
  zero : Nat
  succ : Nat -> Nat

zero : Nat
zero = construct Â«inl (), reflÂ» â€“ :zero

succ : Nat -> Nat
succ n = construct Â«inr (), n, reflÂ» â€“ :succ n

â€“ Somewhere, we store that 'succ' is a constructor, because it was generated by 'data' decl.
â€“ The conversion to locally nameless then knows that, and converts the application to a constructor application

â€“ The type checker then realises that the type will be pushed in, so
â€“ we can determine which constructor is meant. In this way, we can
â€“ overload constructors.

â€“ Need to make sure that constructor names cannot be shadowed

â€“ and we should add a check that we have got the right type. This will
â€“ be some kind of hint in the LocallyNameless syntax

â€“ constructor names are associated with 

Nat:body : Unit + Unit -> IDesc Unit
Nat:body d =
  case d for x. IDesc ğŸ™ with
    { inl _. â€œKâ€ (() â‰¡ ())
    ; inr _. â€œIIdâ€ () â€œÃ—â€ â€œKâ€ (() â‰¡ ())
    }

elimtype :
  (I    : Set) ->
  (C    : Set) ->
  (body : I -> C -> IDesc I) ->
  (P    : (i : I) -> ÂµI I (Î»i. â€œÎ£â€ C (body i)) i -> Set 2) ->
  (i    : I) ->
  (c    : C) ->
  Set 2
elimtype I C body P =
  Î»i c.
    (z : semI I (body i c) (Î»i. ÂµI I (Î»i. â€œÎ£â€ C (body i)) i)) ->
    liftI I (body i c) (Î»i. ÂµI I (Î»i. â€œÎ£â€ C (body i)) i) P z ->
    P i (construct Â«c,zÂ»)

Nat:elim :
  (P : Nat -> Set 2) ->
  P zero ->
  ((n : Nat) -> P n -> P (succ n)) ->
  (n : Nat) ->
  P n
Nat:elim P pzero psucc =
  inductionI Unit Nat:code (Î»_. P)
    (Î»_ Â«c,dÂ». case c for b. elimtype Unit (Unit + Unit) (Î»_. Nat:body) (Î»_. P) () b with
      { inl _. Î»z      _.     rewriteBy z {-for u p. P (construct Â«inl (), pÂ»)-} then pzero
      ; inr _. Î»Â«n,eqÂ» Â«p,_Â». rewriteBy eq {-for u p. P (construct Â«inr (), n, pÂ»)-} then psucc n p
      } d)
    ()

add : Nat -> Nat -> Nat
add nâ‚ nâ‚‚ =
â€“ eliminate nâ‚ with { zero. nâ‚‚; succ nâ‚. succ (recurse nâ‚) }
  inductionI Unit Nat:code (Î»_ _. Nat)
    (Î»g Â«c,dÂ». case c for b. elimtype Unit (Unit + Unit) (Î»_. Nat:body) (Î»_ _. Nat) () b with
      { inl u. Î»z      q.     nâ‚‚ â€“ rewriteBy z for u p. Nat then nâ‚‚
      ; inr _. Î»Â«n,eqÂ» Â«p,_Â». succ p â€“ rewriteBy eq for u p. Nat then succ p
      } d)
    ()
    nâ‚

{-
possible new syntax:
  inductionI x [for i x. P] with T

i, x |- P : Set l
|- T : (i : I) -> (x : semI D (Âµ D) i) -> liftI ... -> P i (construct x)

induction construct z for i x. P with T
=
T i x (all I (D i) (ÂµI I D) P (Î»i x. induction x for i x. P with T))

what is the level of 'all'?
what is the level of 'lift'?
what is the level of 'sem'?

lift can only be defined as map from descriptions to descriptions for
level-0 descriptions, because otherwise we need a higher level
indexes.

-}

{-
vecappend : (A : Set) -> (nâ‚ nâ‚‚ : Nat) -> Vector A nâ‚ -> Vector A nâ‚‚ -> Vector A (add nâ‚ nâ‚‚)
vecappend A nâ‚ nâ‚‚ xs ys =
  eliminate xs with
    vnil.         ys
    vcons n a xs. vcons (add n nâ‚‚) a (recurse xs)

vechead : (A : Set) -> (n : Nat) -> Vector A (succ n) -> A
vechead A n xs = eliminate xs with
  vnil. â€“ empty case
  vcons n a xs. a

acceptsEmpty : (A : Set) -> regexp A -> Bool;
acceptsEmpty A re =
  eliminate re with
    eps.         true
    emp.         false
    alt reâ‚ reâ‚‚. or (recurse reâ‚) (recurse reâ‚‚)
    seq reâ‚ reâ‚‚. and (recurse reâ‚) (recurse reâ‚‚)
    star re.     true
    tok a.       false

step : (A : Set) -> regexp A -> A -> regexp A
step A re a =
  eliminate re with
    eps:
      emp
    emp:
      emp
    alt reâ‚ reâ‚‚:
      alt (recurse reâ‚) (recurse reâ‚‚)
    seq reâ‚ reâ‚‚:
      eliminate acceptsEmpty reâ‚ with
        true:  alt (seq (recurse reâ‚) reâ‚‚) (recurse reâ‚‚)
        false: seq (recurse reâ‚) reâ‚‚
    star re:
      seq (recurse re) (star re)
    tok a':
      eliminate symbol-eq a s' with
        true:  eps
        false: emp

matches : (A : Set) -> List A -> regexp A -> bool
matches by
  introduce A l.
  eliminate l with
    nil:      introduce r. acceptsEmpty A r
    cons a l: introduce r. recurse l (step A r a)

1. look at the type of the thing being looked at
2. Check that it is of the form ÂµI I (Î»i. â€œÎ£â€œ (1 + ... + 1) (Î»b. body)) i
3. Generate a case elimination with the appropriate cases, just ignoring the names for now
4. The patterns get compiled into projections, with a rewrite. So we assume that all the 
5. The "recurse x" things get rewritten somehow, in a later step...

inductionI x for i x. P with blah

-}

data Bool : Set where
  true  : Bool
  false : Bool

â€“ normalise Bool

one : Nat
one = succ zero

{-
normalise
  add one one
-}

{-
introduce P pzero psucc n.
eliminate n with
  introduce _ Â«constructor, argumentsÂ».
  case constructor for c. (z : semI Unit (Nat:body c) (Î»_. Nat ())) ->
                          liftI Unit (Nat:body c) (Î»_. Nat ()) (Î»_. P) z ->
                          P (construct Â«c, argumentsÂ») with
    { inl _. introduce eq _.
      rewriteBy eq then pzero
    ; inr _. introduce Â«n, eqÂ» Â«p, _Â».
      rewriteBy eq then psucc n p
    } arguments

introduce P pzero psucc n.
eliminate n with
  zero.   pzero
  succ n. psucc n (recurse n)

introduce nâ‚ nâ‚‚.
eliminate[plus] nâ‚ with
  zero.   nâ‚‚
  succ n. succ (plus n)

introduce nâ‚.
eliminate[plus] nâ‚ with
  zero.   introduce nâ‚‚. nâ‚‚
  succ n. introduce nâ‚‚. succ (plus n nâ‚‚)

These last three look at the form of the datatype, and use it to
generate the code above. The name of the eliminator tells it how to
translate the recusive calls into references to the proof objects.

To do: deeper recursion, probably with the generic sub-term relation.

To do: elimination-with-a-motive-style enhancing of the inductive
premise and removal of cases that are impossible. Could implement this
with a "ElimEq"-style tactic that attempts to get rid of as many
equalities from the context as possible.

"introduce" should emit a warning if a function type has a name, but
we use a different name in the code.

How would "with" work? If you do something like
  with isZero n
then you either get back a proof that 'n' is zero, or a new number 'm'
and a proof that n = succ m. The plan then is to rewrite all the
hypotheses to include this new information. This could be done with a
new tactic.

-}

data List (A : Set) : Set where
  nil  : List A
  cons : A -> List A -> List A

data Vector (A : Set) : Nat -> Set where
  vnil  : Vector A zero
  vcons : (n : Nat) -> A -> Vector A n -> Vector A (succ n)

â€“ normalise Vector

vnil : (A : Set) -> Vector A zero
vnil A = construct Â«inl (), reflÂ»

vcons : (A : Set) -> (n : Nat) -> A -> Vector A n -> Vector A (succ n)
vcons A n a xs = construct Â«inr (), n, a, xs, reflÂ»

{-
Maybe:

local
  assume A : Set

  data List : Set where
    nil  : List
    cons : A -> List -> List
-}
â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
Vector:body : Set -> Nat -> Unit + Unit -> IDesc Nat;
Vector:body A n b =
  case b for b. IDesc Nat with
    { inl _. â€œKâ€ (zero â‰¡ n)
    ; inr _. â€œÎ£â€ Nat (Î»n'. â€œÎ£â€ A (Î»a. â€œIIdâ€ n' â€œÃ—â€ â€œKâ€(succ n' â‰¡ n)))
    }

Vector:elim :
  (A : Set) ->
  (Î¦ : (n : Nat) -> Vector A n -> Set 2) ->
  Î¦ zero (vnil A) ->
  ((n : Nat) -> (a : A) -> (xs : Vector A n) -> Î¦ n xs -> Î¦ (succ n) (vcons A n a xs)) ->
  (n : Nat) ->
  (xs : Vector A n) ->
  Î¦ n xs
Vector:elim A Î¦ Ï†nil Ï†cons =
  inductionI Nat (Vector:code A) Î¦
    (Î»n Â«constructor, argumentsÂ».
      case constructor for b. elimtype Nat (Unit + Unit) (Vector:body A) Î¦ n b with
        { inl _. Î»z               _.      rewriteBy z {-for n p. Î¦ n (construct Â«inl (), pÂ»)-} then Ï†nil
        ; inr _. Î»Â«n', a, xs, eqÂ» Â«Ï†, _Â». rewriteBy eq {-for n p. Î¦ n (construct Â«inr (), n', a, xs, pÂ»)-} then Ï†cons n' a xs Ï†
        } arguments)

       â€“; inr _. Î»Â«n', a, xs, eqÂ» Â«Ï†, _Â». rewriteBy eq then (Ï†cons n' a xs Ï†)
       â€“; inr Â«n', a, xs, eqÂ». Î»Â«Ï†, _Â». rewriteBy eq then (Ï†cons n' a xs Ï†)

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
data Emp : Set where

normalise Emp

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
data regexp (A : Set) : Set where
  eps  : regexp A
  emp  : regexp A
  alt  : regexp A -> regexp A -> regexp A
  seq  : regexp A -> regexp A -> regexp A
  star : regexp A -> regexp A
  tok  : A -> regexp A
;

{-
data Fin : Nat -> Set where
  { fz : (n : Nat) -> Fin (succ n)
  ; fs : (n : Nat) -> Fin n -> Fin (succ n)
  };
-}
{-
{-

data Foo : Unit -> Set where
  { foo1 : Foo ()
  ; foo2 : Foo ()
  ; foo3 : Foo ()
  ; foo4 : Foo () -> Foo ()
  };
-}

{-
assume lt : Nat () -> Nat () -> Set;

data Acc : Nat () -> Set where
  { acc : (n : Nat ()) -> ((n' : Nat ()) -> lt n' n -> Acc n') -> Acc n
  };
-}

{-
data Acc2 (A : Set) (lt : A -> A -> Set) : A -> Set where
  { acc2 : (a : A) -> ((a' : A) -> lt a' a -> Acc2 A lt a') -> Acc2 A lt a
  };

assume acc2ty :
  (A : Set) ->
  (lt : A -> A -> Set) ->                       â€“ parameters

  (Î¦ : (a : A) -> Acc2 A lt a -> Set) ->        â€“ predicate

  (a : A) ->
  (f : (a' : A) -> lt a' a -> Acc2 A lt a') ->  â€“ constructor arguments

  ((a' : A) -> (x : lt a' a) -> Î¦ a' (f a' x)) -> â€“ induction hypotheses

  Î¦ a (acc2 A lt a f);                            â€“ result
-}

{-
normalise acc2;

data Emp : Nat () -> Set where
  { };
-}
