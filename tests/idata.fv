data Nat : Set where
  zero : Nat
  succ : Nat -> Nat

zero : Nat
zero = construct «inl (), refl» – :zero

succ : Nat -> Nat
succ n = construct «inr (), n, refl» – :succ n

– Somewhere, we store that 'succ' is a constructor, because it was generated by 'data' decl.
– The conversion to locally nameless then knows that, and converts the application to a constructor application

– The type checker then realises that the type will be pushed in, so
– we can determine which constructor is meant. In this way, we can
– overload constructors.

– Need to make sure that constructor names cannot be shadowed

– and we should add a check that we have got the right type. This will
– be some kind of hint in the LocallyNameless syntax

– constructor names are associated with 

Nat:body : Unit + Unit -> IDesc Unit
Nat:body d =
  case d with
    { inl _. “K” (() ≡ ())
    ; inr _. “IId” () “×” “K” (() ≡ ())
    }

elimtype :
  (I    : Set) ->
  (C    : Set) ->
  (body : I -> C -> IDesc I) ->
  (P    : (i : I) -> µI I (λi. “Σ” C (body i)) i -> Set 2) ->
  (i    : I) ->
  (c    : C) ->
  Set 2
elimtype I C body P =
  λi c.
    (z : semI[body i c, i. µI I (λi. “Σ” C (body i)) i]) ->
    liftI[body i c, i. µI I (λi. “Σ” C (body i)) i, i x. P i x, z] ->
    P i (construct «c,z»)

Nat:elim :
  (P : Nat -> Set 2) ->
  P zero ->
  ((n : Nat) -> P n -> P (succ n)) ->
  (n : Nat) ->
  P n
Nat:elim P pzero psucc =
  inductionI Unit Nat:code (λ_. P)
    (λ_ «c,d». case c for b. elimtype Unit (Unit + Unit) (λ_. Nat:body) (λ_. P) () b with
      { inl _. λz      _.     rewriteBy z {-for u p. P (construct «inl (), p»)-} then pzero
      ; inr _. λ«n,eq» «p,_». rewriteBy eq {-for u p. P (construct «inr (), n, p»)-} then psucc n p
      } d)
    ()

add : Nat -> Nat -> Nat
add n₁ n₂ =
– eliminate n₁ with { zero. n₂; succ n₁. succ (recurse n₁) }
  inductionI Unit Nat:code (λ_ _. Nat)
    (λg «c,d». case c for b. elimtype Unit (Unit + Unit) (λ_. Nat:body) (λ_ _. Nat) () b with
      { inl u. λz      q.     n₂ – rewriteBy z for u p. Nat then n₂
      ; inr _. λ«n,eq» «p,_». succ p – rewriteBy eq for u p. Nat then succ p
      } d)
    ()
    n₁

{-
vecappend : (A : Set) -> (n₁ n₂ : Nat) -> Vector A n₁ -> Vector A n₂ -> Vector A (add n₁ n₂)
vecappend A n₁ n₂ xs ys =
  eliminate xs with
    vnil.         ys
    vcons n a xs. vcons (add n n₂) a (recurse xs)

vechead : (A : Set) -> (n : Nat) -> Vector A (succ n) -> A
vechead A n xs = eliminate xs with
  vnil. – empty case
  vcons n a xs. a

acceptsEmpty : (A : Set) -> regexp A -> Bool;
acceptsEmpty A re =
  eliminate re with
    eps.         true
    emp.         false
    alt re₁ re₂. or (recurse re₁) (recurse re₂)
    seq re₁ re₂. and (recurse re₁) (recurse re₂)
    star re.     true
    tok a.       false

step : (A : Set) -> regexp A -> A -> regexp A
step A re a =
  eliminate re with
    eps:
      emp
    emp:
      emp
    alt re₁ re₂:
      alt (recurse re₁) (recurse re₂)
    seq re₁ re₂:
      eliminate acceptsEmpty re₁ with
        true:  alt (seq (recurse re₁) re₂) (recurse re₂)
        false: seq (recurse re₁) re₂
    star re:
      seq (recurse re) (star re)
    tok a':
      eliminate symbol-eq a s' with
        true:  eps
        false: emp

matches : (A : Set) -> List A -> regexp A -> bool
matches by
  introduce A l.
  eliminate l with
    nil:      introduce r. acceptsEmpty A r
    cons a l: introduce r. recurse l (step A r a)

1. look at the type of the thing being looked at
2. Check that it is of the form µI I (λi. “Σ“ (1 + ... + 1) (λb. body)) i
3. Generate a case elimination with the appropriate cases, just ignoring the names for now
4. The patterns get compiled into projections, with a rewrite. So we assume that all the 
5. The "recurse x" things get rewritten somehow, in a later step...

inductionI x for i x. P with blah

-}

data Bool : Set where
  true  : Bool
  false : Bool

– normalise Bool

one : Nat
one = succ zero

{-
normalise
  add one one
-}

{-
introduce P pzero psucc n.
eliminate n with
  zero.   pzero
  succ n. psucc n (recurse n)

introduce n₁ n₂.
eliminate[plus] n₁ with
  zero.   n₂
  succ n. succ (plus n)

introduce n₁.
eliminate[plus] n₁ with
  zero.   introduce n₂. n₂
  succ n. introduce n₂. succ (plus n n₂)

These last three look at the form of the datatype, and use it to
generate the code above. The name of the eliminator tells it how to
translate the recusive calls into references to the proof objects.

To do: deeper recursion, probably with the generic sub-term relation.

To do: elimination-with-a-motive-style enhancing of the inductive
premise and removal of cases that are impossible. Could implement this
with a "ElimEq"-style tactic that attempts to get rid of as many
equalities from the context as possible.

"introduce" should emit a warning if a function type has a name, but
we use a different name in the code.

How would "with" work? If you do something like
  with isZero n
then you either get back a proof that 'n' is zero, or a new number 'm'
and a proof that n = succ m. The plan then is to rewrite all the
hypotheses to include this new information. This could be done with a
new tactic.

-}

data List (A : Set) : Set where
  nil  : List A
  cons : A -> List A -> List A

data Vector (A : Set) : Nat -> Set where
  vnil  : Vector A zero
  vcons : (n : Nat) -> A -> Vector A n -> Vector A (succ n)

– normalise Vector

vnil : (A : Set) -> Vector A zero
vnil A = construct «inl (), refl»

vcons : (A : Set) -> (n : Nat) -> A -> Vector A n -> Vector A (succ n)
vcons A n a xs = construct «inr (), n, a, xs, refl»

{-
Maybe:

local
  assume A : Set

  data List : Set where
    nil  : List
    cons : A -> List -> List
-}
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
Vector:body : Set -> Nat -> Unit + Unit -> IDesc Nat;
Vector:body A n b =
  case b with
    { inl _. “K” (zero ≡ n)
    ; inr _. “Σ” Nat (λn'. “Σ” A (λa. “IId” n' “×” “K”(succ n' ≡ n)))
    }

Vector:elim :
  (A : Set) ->
  (Φ : (n : Nat) -> Vector A n -> Set 2) ->
  Φ zero (vnil A) ->
  ((n : Nat) -> (a : A) -> (xs : Vector A n) -> Φ n xs -> Φ (succ n) (vcons A n a xs)) ->
  (n : Nat) ->
  (xs : Vector A n) ->
  Φ n xs
Vector:elim A Φ φnil φcons =
  inductionI Nat (Vector:code A) Φ
    (λn «constructor, arguments».
      case constructor for b. elimtype Nat (Unit + Unit) (Vector:body A) Φ n b with
        { inl _. λz               _.      rewriteBy z {-for n p. Φ n (construct «inl (), p»)-} then φnil
        ; inr _. λ«n', a, xs, eq» «φ, _». rewriteBy eq {-for n p. Φ n (construct «inr (), n', a, xs, p»)-} then φcons n' a xs φ
        } arguments)

       –; inr _. λ«n', a, xs, eq» «φ, _». rewriteBy eq then (φcons n' a xs φ)
       –; inr «n', a, xs, eq». λ«φ, _». rewriteBy eq then (φcons n' a xs φ)

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
data Emp : Set where

normalise Emp

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
data regexp (A : Set) : Set where
  eps  : regexp A
  emp  : regexp A
  alt  : regexp A -> regexp A -> regexp A
  seq  : regexp A -> regexp A -> regexp A
  star : regexp A -> regexp A
  tok  : A -> regexp A
;

data Fin : Nat -> Set where
  fz : (n : Nat) -> Fin (succ n)
  fs : (n : Nat) -> Fin n -> Fin (succ n)

{-
{-

data Foo : Unit -> Set where
  { foo1 : Foo ()
  ; foo2 : Foo ()
  ; foo3 : Foo ()
  ; foo4 : Foo () -> Foo ()
  };
-}

{-
assume lt : Nat () -> Nat () -> Set;

data Acc : Nat () -> Set where
  { acc : (n : Nat ()) -> ((n' : Nat ()) -> lt n' n -> Acc n') -> Acc n
  };
-}

{-
data Acc2 (A : Set) (lt : A -> A -> Set) : A -> Set where
  { acc2 : (a : A) -> ((a' : A) -> lt a' a -> Acc2 A lt a') -> Acc2 A lt a
  };

assume acc2ty :
  (A : Set) ->
  (lt : A -> A -> Set) ->                       – parameters

  (Φ : (a : A) -> Acc2 A lt a -> Set) ->        – predicate

  (a : A) ->
  (f : (a' : A) -> lt a' a -> Acc2 A lt a') ->  – constructor arguments

  ((a' : A) -> (x : lt a' a) -> Φ a' (f a' x)) -> – induction hypotheses

  Φ a (acc2 A lt a f);                            – result
-}

{-
normalise acc2;

data Emp : Nat () -> Set where
  { };
-}

data Eq (A : Set) (a : A) : A -> Set where
  reflexivity : Eq A a a

normalise Eq;
 
assume A : Set
assume a : A

normalise inductionI A (Eq:code A a);


;