{-

This file defines ‘inductors’: abstract induction principles.

Changes:
 20110209 : Added GCD example



An inductor for a type ‘A’ consists of two parts:

 1. A predicate transformer ‘H : (A → Set) → (A → Set)’. This will
    actually be a description of a predicate transformer, so it will
    have type ’A → IDesc A’. The ‘semI'’ function (defined below)
    realises descriptions as actual predicate transformers.

 2. An induction combinator of type
   (Φ : A → Set) → ((x : A) → semI' A A H Φ x → Φ x) → (x : A) → Φ x

The basic idea is that inductors describe and implement well-founded
ways that the datatype ‘A’ can be explored. The predicate transformer
‘H’ takes an ‘A’-predicate ‘Φ’ and an ‘A’-value ‘a’ and provides
access to ‘Φ a₁’ for all the ‘a₁’ that are accessible from ‘a’. For
normal structural induction this will be all immediate subterms of
‘a’; for complete structural induction this will be all proper
subterms of ‘a’. An inductor for ‘A’ implicitly describes a
well-founded ordering of the type ‘A’.

Inductors are generalisations of recursion schemes from functional
programming. The generalisation comes from the ability to generate
indexed data from a recursion, meaing that the type of the final
result can depend on the starting ‘A’ value.

This file presents several ways of building up inductors using
combinators. This contrasts to the typical approaches of building
non-standard (i.e. not structural) induction principles in type theory:

 1. Using separate ‘match’ and ‘fixpoint’ operators along with a
    syntactic termination checker. This is the approach taken by Coq,
    and, I think, by Agda.

 2. Allowing arbitrary well-founded induction and deriving all other
    induction principles from this. This is the approach taken by
    Paulson in “Constructing Recursion Operators in Intuitionistic
    Type Theory”. It is also possible to take this approach in a
    system with powerful enough structural induction (which includes
    Coq and Agda).

The approach taken here has several direct inspirations:

 1. Programming using eliminators, as advocated by McBride in his
    thesis and along with McKinna in “The View from the Left”. McBride
    also references Gimenez for a general way of constructing a
    complete-induction elimination principle from basic structural
    induction.

 2. The “Data.Induction” module in the Agda standard library, written
    (I think) by Danielsson. There, the abstract induction principles
    are called “recursors”.

 3. The approach of deriving recursion schemes from the basic
    iteration scheme for initial algebras as in the “Algebra of
    Programming” literature. See, for example, Vene's thesis for a
    categorical account.

The main change in this development with respect to previous work is
to make the predicate transformer portion be an explicit (indexed)
description of a datatype. This allows the construction of induction
principles that require the predicate transformer portion to be a
functor.

As it stands, there are several known shortcomings of the present work:

 1. While each of the inductors described below has an intended
    computational behaviour, it is not possible to easily state what
    this is. Even if it were, I don't know how to express this
    internally within the inductor type. A possible way around this is
    given at the end of this file, but not yet developed.

 2. It is not possible to fully complete the complete induction
    example, due to either: lack of knowledge of the computational
    behaviour of inductors (which prohbits the computational
    construction of the memoisation table); or the lack of nested
    fixpoints (which prohbits the other possible construction
    technique). It might be possible to overcome this by constructing
    a generic generalised “subterm” relation and using that.

 3. Only induction on non-indexed data is handled. I believe that this
    is a minor problem, and handling indexed data just requires more
    indicies to be ferried around to the right places.

 4. Several times in the later parts of the development, the fact that
    descriptions form a monad, and the semantic realisation of
    descriptions is a monad morphism is used. It would be nice if
    these facts held definitionally.

-}

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– First some basic functions that we will need. First for non-indexed
– descriptions of functors Set → Set.
lift' : (D : Desc) →
       (α : Set) →
       (Φ : α → Set 1) →
       sem D α → Set 2 ;
lift' D α Φ = elimD (λD. sem D α → Set 2)
                    (λA x. Unit)
                    (λx. Φ x)
                    (λF G f g x. f (fst x) × g (snd x))
                    (λF G f g x. case x with
                                   { inl y. f y
                                   ; inr z. g z
                                   })
                    D;
{-
lift' : (D : Desc) →
        (α : Set) →
        (Φ : α → Set 2) →
        sem D α → Set 2 ;
lift' D α Φ = elimD (λD. sem D α → Set 2)
                    (λA x. Unit)
                    (λx. Φ x)
                    (λF G f g x. f (fst x) × g (snd x))
                    (λF G f g x. case x for d. Set 2 with
                                   { inl y. f y
                                   ; inr z. g z
                                   })
                    D;
-}
all : (D : Desc) →
      (X : Set) →
      (P : X → Set 1) →
      (p : (x : X) → P x) →
      (xs : sem D X) →
      lift' D X P xs ;
all D X P p = elimD (\D. (xs : sem D X) → lift' D X P xs)
                    (\A x. ())
                    (\x. p x)
                    (\F G f g x. «f (fst x), g (snd x)»)
                    (\F G f g x. case x for d. lift' (F “+” G) X P d with
                                    { inl y. f y
                                    ; inr z. g z
                                    }) 
                   D;

deconstruct : (D : Desc) → µ D → sem D (µ D);
deconstruct D = induction D (λx. sem D (µ D)) (λx p. x);

caseD : (D : Desc) →
        (Φ : µ D → Set 2) →
        ((x : sem D (µ D)) → Φ (construct x)) →
        (x : µ D) → Φ x;
caseD D Φ k =
  induction D (λx. Φ x) (λx φ. k x);

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– Some things for indexed descriptions.
semI' : (I J : Set) → (I → IDesc J) → (J → Set 1) → (I → Set 1);
semI' I J D X i = semI[D i, j. X j];

– Composition of descriptions of indexed functors. The type of this 
– function is deliberately phrased to look like a monadic bind operator.
– It would be nice in the future to build in the knowledge that IDesc
– is a monad, and let the monad rules hold definitionally.
compose : (A B : Set) → IDesc A → (A → IDesc B) → IDesc B;
compose A B D f = elimID A (λD. IDesc B)
                         (λa. f a)
                         (λA. “K” A)
                         (λD₁ D₂ d₁ d₂. d₁ “×” d₂)
                         (λC D g. “Σ” C g)
                         (λC D g. “Π” C g)
                         D;

– The semI function is actually a monad morphism. This function
– witnesses this fact. Again, it would be nice if this held
– definitionally.
commute : (I J : Set) →
          (D₁ : IDesc I) →
          (D₂ : I → IDesc J) →
          (Φ  : J → Set 1) →
          semI[D₁, a. semI[D₂ a, j. Φ j]] →
          semI[compose I J D₁ D₂, j. Φ j];
commute I J D₁ D₂ Φ =
  elimID I (λD₁. semI[D₁, a. semI[D₂ a, j. Φ j]] → semI[compose I J D₁ D₂, j. Φ j])
         (λi x. x)
         (λA a. a)
         (λD₁ D₂ c₁ c₂ p. «c₁ (fst p), c₂ (snd p)»)
         (λA D g p. «fst p, g (fst p) (snd p)»)
         (λA D g f. λa. g a (f a))
         D₁;

commute2 : (I J : Set) →
           (D₁ : IDesc I) →
           (D₂ : I → IDesc J) →
           (Φ  : J → Set 1) →
           semI[compose I J D₁ D₂, j. Φ j] →
           semI[D₁, a. semI[D₂ a, j. Φ j]];
commute2 I J D₁ D₂ Φ =
  elimID I (λD₁. semI[compose I J D₁ D₂, j. Φ j] → semI[D₁, a. semI[D₂ a, j. Φ j]])
         (λi x. x)
         (λA a. a)
         (λD₁ D₂ c₁ c₂ p. «c₁ (fst p), c₂ (snd p)»)
         (λA D g p. «fst p, g (fst p) (snd p)»)
         (λA D g f. λa. g a (f a))
         D₁;

– Every indexed description defines a functor. This function provides
– the map functionality. Again, it would be nice if the functor laws
– held definitionally.
map : (A : Set) →
      (D : IDesc A) →
      (Φ Ψ : A → Set 1) →
      (f : (a : A) → Φ a → Ψ a) →
      semI[D, a. Φ a] →
      semI[D, a. Ψ a]
map A D Φ Ψ f =
 elimID A (λD'. semI[D', a. Φ a] → semI[D', a. Ψ a])
        f
        (λA a. a)
        (λD₁ D₂ map₁ map₂ p. «map₁ (fst p), map₂ (snd p)»)
        (λA D map p. «fst p, map (fst p) (snd p)»)
        (λA D map f. λa. map a (f a))
        D;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– The definition of inductors, as described above. We assume that
– elimination into ‘Set 1’ is allowed, for flexibility.
inductor : Set → Set 2;
inductor A = (H : A → IDesc A) ×
             ((Φ : A → Set 1) →
              ((x : A) → semI[H x, a. Φ a] → Φ x) →
              (x : A) → Φ x);

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– Every unindexed inductive type ‘µ D’ has an inductor. We need to
– first express the predicate transformer part of the built-in induction
– principle for ‘µ D’ types as an IDesc, and then show that we can
– convert from one to the other. It might be better to provide the
– built-in induction principle using the IDesc formulation.
lift2 : (D : Desc) →
        (A : Set) →
        sem D A →
        IDesc A;
lift2 D A = elimD (λD. sem D A → IDesc A)
                  (λA' x. “K” Unit)
                  (λx. “IId” x)
                  (λD₁ D₂ f g x. f (fst x) “×” g (snd x))
 		  (λD₁ D₂ f g x. case x for d. IDesc A with
		                   { inl y. f y
		 		   ; inr z. g z
				   })
                  D;

lift-to-lift2 : (D : Desc) →
                (A : Set) →
                (Φ : A → Set 1) →
                (x : sem D A) →
                lift' D A Φ x →
                semI[lift2 D A x, a. Φ a];
lift-to-lift2 D A Φ =
  elimD (λD'. (x : sem D' A) → lift' D' A Φ x → semI[lift2 D' A x, a. Φ a])
        (λA x u. ⋄)
        (λx p. p)
        (λD₁ D₂ f₁ f₂ x p. « f₁ (fst x) (fst p), f₂ (snd x) (snd p) »)
        (λD₁ D₂ f₁ f₂ x.
            case x with
              { inl y. λa. f₁ y a
              ; inr z. λb. f₂ z b
              })
        D;

lift2-to-lift : (D : Desc) →
                (A : Set) →
                (Φ : A → Set 1) →
                (x : sem D A) →
                semI[lift2 D A x, a. Φ a] →
                lift' D A Φ x;
lift2-to-lift D A Φ =
  elimD (λD'. (x : sem D' A) → semI[lift2 D' A x, a. Φ a] → lift' D' A Φ x)
        (λA x u. ⋄)
        (λx p. p)
        (λD₁ D₂ f₁ f₂ x p. « f₁ (fst x) (fst p), f₂ (snd x) (snd p) »)
        (λD₁ D₂ f₁ f₂ x.
            case x with
              { inl y. λa. f₁ y a
              ; inr z. λb. f₂ z b
              })
        D;

desc-inductor : (D : Desc) → inductor (µ D);
desc-inductor D =
  « λx. lift2 D (µ D) (deconstruct D x)
  , λΦ k. induction D (λx. Φ x) (λx p. k (construct x) (lift-to-lift2 D (µ D) Φ x p))
  »;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– This is an inductor which imposes a lexicographic ordering on a pair
– of inductors. Given a pair «a,b», one can either move down on ‘b’, 
– leaving ‘a’ as is; or move down on ‘a’, and move to arbitrary ‘b’.

– Two helper functions for constructing little ‘IDesc’s.
bleh : (A B : Set) → A → IDesc (A × B);
bleh A B a = “Π” B (λb. “IId” «a,b»);

bloo : (A B : Set) → A → B → IDesc (A × B);
bloo A B a b = “IId” «a,b»;

lex-inductor : (A : Set) → inductor A →
               (B : Set) → inductor B →
               inductor (A × B);
lex-inductor A AI B BI =
  « λp.     compose A (A × B) (fst AI (fst p)) (bleh A B)
        “×” compose B (A × B) (fst BI (snd p)) (bloo A B (fst p))
  , λΦ k p. snd AI (λa. (b : B) → Φ «a,b»)
                   (λa φa. snd BI (λb. Φ «a,b»)
                                  (λb φb. k «a,b»
                                            « commute A (A × B) (fst AI a) (bleh A B) Φ φa
                                            , commute B (A × B) (fst BI b) (bloo A B a) Φ φb
                                            »))
                   (fst p)
                   (snd p)
  »;
– Note the use of ‘commute’ in the above definition, if the equality 
– partially witnessed by ‘commute’ held definitionally, these parts
– would just disappear.

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– The following inductor works for any type ‘A’, but provides a 
– trivial inductive hypothesis. I think of this as a set equipped with
– the “flat” ordering. Combining this with the other combinators can
– provide a more interesting order structure.

– Maybe this should be called a “cenomorphism”?
flat : (A : Set) → inductor A;
flat A = « λx. “K” Unit
         , λΦ k x. k x ⋄
         »;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– The following combinator works on pairs, as the lexicographic one
– above, but encodes a different strategy: Given an element «a,b», one
– can either move down on ‘a’ or down on ‘b’.

– This construction requires the knowledge that the predicate
– transformer is actually a functor, which we can provide here because
– we have an explicit description.

floo : (A B : Set) → B → A → IDesc (A × B);
floo A B b a = “IId” «a,b»;

pair-inductor : (A : Set) → inductor A →
                (B : Set) → inductor B →
                inductor (A × B);
pair-inductor A AI B BI =
  « λp.     compose A (A × B) (fst AI (fst p)) (floo A B (snd p))
        “×” compose B (A × B) (fst BI (snd p)) (bloo A B (fst p))
  , λΦ k p. snd AI (λa. (b : B) → Φ «a,b»)
                   (λa φa. snd BI (λb. Φ «a,b»)
                                  (λb φb. k «a,b»
                                            « commute A (A × B)
                                                      (fst AI a)
                                                      (floo A B b)
                                                      Φ
                                                      (map A (fst AI a)
                                                           (λa. (b : B) → Φ «a,b»)
                                                           (λa. Φ «a,b»)
                                                           (λa f. f b)
                                                           φa)
                                            , commute B (A × B) (fst BI b) (bloo A B a) Φ φb
                                            »))
                   (fst p)
                   (snd p)
  »;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
fleh : (A B : Set) → B → IDesc (A × B);
fleh A B b = “Π” A (λa. “IId” «a,b»);

– I don't think this one works...

{-
pair2-inductor : (A : Set) → inductor A →
                 (B : Set) → inductor B →
                 inductor (A × B);
pair2-inductor A AI B BI =
  « λp.     compose A (A × B) (fst AI (fst p)) (bleh A B)
        “×” compose B (A × B) (fst BI (snd p)) (fleh A B)
  , λΦ k p. snd AI (λa. (b : B) → Φ «a,b»)
                   (λa φa. snd BI (λb. (a : A) → Φ «a,b»)
                                  (λb φb a'. k «a',b» « (), () »))
                   (fst p)
                   (snd p)
  »;
-}

{-
– this would work if inductors included the truth preservation witness

pair3-inductor : (A : Set) → inductor A →
                 (B : Set) → inductor B →
                 inductor (A × B);
pair3-inductor A AI B BI =
  « λp. compose A (A × B) (fst AI (fst p)) (λa. compose B (A × B) (fst BI (snd p)) (λb. “IId” «a,b»))
  , λΦ k p. snd AI (λa. (b : B) → Φ «a,b»)
                   (λa φ. snd BI (λb. Φ «a,b»)
                                 (λb ψ. k «a,b» ψ)) – this bit (‘ψ’) is wrong
                   (fst p)
                   (snd p)
  »;
-}

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– The following two combinators build new inductors from old by
– adjoining new elements to the original type, conceptually at the “top”
– and the “bottom”, when the well-founded order is thought of as
– having “no infinite ascending chains”. The reason for this peverse
– inversion is thought of possible applications in proving the
– termination of abstract interpretation/data flow analysis programs.

maybe : Set → Set;
maybe A = Unit + A;

– Generate a new inductor for ‘maybe A’ from one for ‘A’. When at the
– bottom element (‘inl ⋄’), one can move to any ‘a’. When at any ‘a’,
– exploration proceeds according to the original inductor.
with-bottom : (A : Set) → inductor A → inductor (maybe A);
with-bottom A AI =
  « λx. case x with
          { inl u. “Π” A (λa. “IId” (inr a))
          ; inr a. compose A (maybe A) (fst AI a) (λa. “IId” (inr a))
          }
  , λΦ k x. case x with
              { inl u.
                  k (inl u)
                    (snd AI (λa. Φ (inr a))
                            (λa φ. k (inr a)
                                     (commute A (maybe A) (fst AI a) (λa. “IId” (inr a)) Φ φ)))
              ; inr a.
                  snd AI (λa. Φ (inr a))
                         (λa φ. k (inr a)
                                  (commute A (maybe A) (fst AI a) (λa. “IId” (inr a)) Φ φ))
                         a
              }
  »;

– Generate a new inductor for ‘maybe A’ from one for ‘A’. When at the
– top element (‘inl ⋄’), one cannot make any move. When at any ‘a’,
– exploration can proceed according to the original inductor, or can go
– directly to the top element.
with-top : (A : Set) → inductor A → inductor (maybe A);
with-top A AI =
  « λx. case x with
          { inl u. “K” Unit
          ; inr a. compose A (maybe A) (fst AI a) (λa. “IId” (inr a)) “×” “IId” (inl ⋄)
          }
  , λΦ k x. case x with
              { inl u. k (inl u) ⋄
              ; inr a. snd AI (λa. Φ (inr a))
                        (λa φ. k (inr a)
                                 « commute A (maybe A) (fst AI a) (λa. “IId” (inr a)) Φ φ
                                 , k (inl ⋄) ⋄
                                 »)
                        a
              }
  »;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– As observed by Vene (and Uustalu?), many recursion schemes in
– functional programming can be expressed as instances of a general
– comonadic recursion scheme. This includes the derivation of primitive
– recursion, and of course-of-values recursion.

– We develop this idea here for inductors.

– Comonads on ‘A’-indexed sets, but without the laws. We use IDesc to
– describe the functor part, which ensures that it is definitely a
– functor.
comonad : Set → Set 3;
comonad A = (W      : A → IDesc A) ×
            (counit : (P : A → Set 1) → (a : A) → semI[W a, a. P a] → P a) ×
	    (cojoin : (P : A → Set 1) → (a : A) → semI[W a, a. P a] → semI[W a, a. semI[W a, a. P a]]) ×
            Unit;

– Projection functions for comonads. We’ll just use ‘fst W’ to get the
– functor part of the comonad.
counit : (A : Set) → (W : comonad A) →
         (P : A → Set 1) →
         (a : A) →
         semI[fst W a, a. P a] →
         P a;
counit A W = fst (snd W);

cojoin : (A : Set) → (W : comonad A) →
         (P : A → Set 1) →
         (a : A) →
         semI[fst W a, a. P a] →
         semI[fst W a, a. semI[fst W a, a. P a]];
cojoin A W = fst (snd (snd W));

– Given a inductor some type ‘A’, a comonad on ‘A’-indexed sets, and a
– distributive law relating the comonad to the predicate transformer of
– the inductor, this function constructs an inductor for ‘A’ where the
– inductive hypothesis has been augmented by the comonad.
comonadic-inductor : (A  : Set) →
                     (W  : comonad A) →
                     (AI : inductor A) →
                     (d  : (P : A → Set 1) →
                           (a : A) →
                           semI' A A (fst AI) (semI' A A (fst W) P) a →
                           semI' A A (fst W) (semI' A A (fst AI) P) a) →
                     inductor A;
comonadic-inductor A W AI d =
  « λa. compose A A (fst AI a) (fst W)
  , λΦ k a. counit A W Φ a (snd AI (semI' A A (fst W) Φ)
                                (λa φ. map A (fst W a)
                                           (semI' A A (fst AI) (semI' A A (fst W) Φ))
                                           Φ
				           (λa φ. k a (commute A A (fst AI a) (fst W) Φ φ))
                                           (d (semI' A A (fst W) Φ)
                                               a
                                               (map A (fst AI a)
                                                    (semI' A A (fst W) Φ)
                                                    (semI' A A (fst W) (semI' A A (fst W) Φ))
                                                    (cojoin A W Φ)
                                                    φ)))
                                a)
  »;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– Given a inductive proof of some property Ψ with respect to some inductor, we
– can “fold” it into an inductor. This is the induction version of the primitive
– recursion scheme.
primitive-inductor : (A  : Set) →
                     (AI : inductor A) →
                     (Ψ  : A → Set) →
                     (k  : (x : A) → semI' A A (fst AI) (λa. Ψ a) x → Ψ x) →
                     inductor A;
primitive-inductor A AI Ψ k =
  comonadic-inductor
    A
    « λa. “K” (Ψ a) “×” “IId” a, – the comonad's functor
    « λΦ a p. snd p,                      – the counit
    « λΦ a p. « fst p, p », ⋄ »»»         – the cojoin
    AI
    (λΦ a φ.
      « k a (map A (fst AI a) (λa. Ψ a × Φ a) (λa. Ψ a) (λa φ. fst φ) φ)
      , map A (fst AI a) (λa. Ψ a × Φ a) (λa. Φ a) (λa φ. snd φ) φ
      »);

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– Complete Induction

– The main application of the comonadic induction rule is to complete
– induction, where all of the ‘lower’ results of the computation are
– available.

– In the recursion schemes world, Uustalu and Vene showed that there
– are two possible ways of defining something that looks like complete
– recursion, using least and greatest fixpoints.

– In the inductor world, we want to instantiate the comonadic
– induction scheme with the comonad with the following carrier:
– 
–   W Φ = µ Y. (Φ × H Y)
–

– where H is the induction hypothesis builder of the inductor that we
– are building on. Not that, because this type is indexed by A and the
– use of H controls the amount of available unfolding, there would be no
– difference between least and greatest fix points here.

– Unfortunately, it is not possible to express this data structure in
– this language as it stands because descriptions of types are not
– closed under taking fix points. An alternative approach is to compute
– the required description of a type. We explore this below.

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– This is an attempt to define complete induction by making use of a
– memoisation table. To build the type of the memoisation table I have
– attempted to use the inductor itself, since it can generate values in ‘Set 1’.
– However, because the inductor doesn't have any computational meaning (it
– doesn't reduce), I can't get access to the computed type at any time, so I
– wasn't able to define the counit and cojoin of the comonad. I think, unless
– something else is going wrong. It might also be a consequence of the way that 
– the inductor type is defined (without a “sub-structure” type).

– ‘collapse’ ignores the data stored in the argument φ, it is only using it for 
– its structure. I'm fairly sure this is the right thing to do.
collapse : (A : Set) →
           (H : IDesc A) →
           (φ : semI[H, a. IDesc A]) →
           IDesc A;
collapse A =
  elimID A (λD. semI[D, a. IDesc A] → IDesc A)
         (λa D. D)
         (λA' a'. “K” A')
         (λD₁ D₂ rec₁ rec₂ p. rec₁ (fst p) “×” rec₂ (snd p))
         (λB D rec p. “Σ” B (λb. rec (fst p) (snd p)))
         (λB D rec f. “Π” B (λb. rec b (f b)));

complete-carrier : (A  : Set) →
                   (AI : inductor A) →
                   A → IDesc A;
complete-carrier A AI =
  snd AI (λa. IDesc A)
         (λa φ. “IId” a “×” collapse A (fst AI a) φ);

– The problem now is that, when we provide ‘complete-carrier’ with a
– concrete ‘A’, the system does not know anything about how such a thing
– will reduce. So we cannot define the counit.

{-
complete-counit :
  (A  : Set) →
  (AI : inductor A) →
  (Φ  : A → Set 1) → (a : A) → semI' A A (complete-carrier A AI) Φ a → Φ a;
complete-counit A AI Φ =
  snd AI (λa. semI' A A (complete-carrier A AI) Φ a → Φ a)
      (λa d. ());
-}

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– This is a successful attempt to construct the carrier for complete
– induction, but this time specialising only to the case when the base
– inductor is the one derived from an inductive type. In this case, we know
– that the necessary reduction steps will take place and we will be able to
– define the counit, cojoin and so on.

– The function ‘collapse2’ takes something in ‘\hat{D} (λx. IDesc X)
– x’ and returns a description of composing \hat{D} with all the
– descriptions stored at the leaves of the arguments. This
– circumlocution is required in order to define the type we want
– recursively.
–
– The ‘step’ and ‘unstep’ functions below witness the conversions back
– and forth.
collapse2 : (D : Desc) →
            (X : Set) →
            (x : sem D X) →
            (φ : lift' D X (λx. IDesc X) x) →
            IDesc X;
collapse2 D X =
  elimD (λD'. (x : sem D' X) → lift' D' X (λx. IDesc X) x → IDesc X)
        (λA x u. “K” Unit)
        (λx ID. ID)
        (λD₁ D₂ f₁ f₂ x p. f₁ (fst x) (fst p) “×” f₂ (snd x) (snd p))
        (λD₁ D₂ f₁ f₂ x. case x with
                           { inl x₁. f₁ x₁
                           ; inr x₂. f₂ x₂
                           })
        D;

step :
  (D : Desc) →
  (Ψ : µ D → IDesc (µ D)) →
  (Φ : µ D → Set 1) →
  (x : sem D (µ D)) →
  lift' D (µ D) (semI' (µ D) (µ D) Ψ Φ) x →
  semI[collapse2 D (µ D) x (all D (µ D) (λx. IDesc (µ D)) Ψ x), x. Φ x];
step D Ψ Φ =
  elimD (λD'. (x : sem D' (µ D)) →
              lift' D' (µ D) (semI' (µ D) (µ D) Ψ Φ) x →
              semI[collapse2 D' (µ D) x (all D' (µ D) (λx. IDesc (µ D)) Ψ x), x. Φ x])
    (λA x u. ⋄)
    (λx p. p)
    (λD₁ D₂ step₁ step₂ x p.
      « step₁ (fst x) (fst p)
      , step₂ (snd x) (snd p)
      »)
    (λD₁ D₂ step₁ step₂ x.
      case x with
        { inl x₁. step₁ x₁
        ; inr x₂. step₂ x₂
        })
    D;

unstep :
  (D : Desc) →
  (Ψ : µ D → IDesc (µ D)) →
  (Φ : µ D → Set 1) →
  (x : sem D (µ D)) →
  semI[collapse2 D (µ D) x (all D (µ D) (λx. IDesc (µ D)) Ψ x), x. Φ x] →
  lift' D (µ D) (semI' (µ D) (µ D) Ψ Φ) x;
unstep D Ψ Φ =
  elimD (λD'. (x : sem D' (µ D)) →
              semI[collapse2 D' (µ D) x (all D' (µ D) (λx. IDesc (µ D)) Ψ x), x. Φ x] →
              lift' D' (µ D) (semI' (µ D) (µ D) Ψ Φ) x)
    (λA x u. ⋄)
    (λx p. p)
    (λD₁ D₂ unstep₁ unstep₂ x p.
      « unstep₁ (fst x) (fst p)
      , unstep₂ (snd x) (snd p)
      »)
    (λD₁ D₂ unstep₁ unstep₂ x.
      case x with
        { inl x₁. unstep₁ x₁
        ; inr x₂. unstep₂ x₂
        })
    D;

– We can now define the carrier for complete induction on an inductive
– type by recursion on the structure of the element that is currently
– being observed.
complete2-carrier : (D : Desc) → µ D → IDesc (µ D);
complete2-carrier D =
  induction D (λx. IDesc (µ D))
    (λx φ. “IId” (construct x) “×” collapse2 D (µ D) x φ);

– The counit is effectively just first projection.
complete2-counit :
  (D : Desc) →
  (Φ : µ D → Set 1) → (x : µ D) → semI' (µ D) (µ D) (complete2-carrier D) Φ x → Φ x;
complete2-counit D Φ =
  caseD D (λx. semI' (µ D) (µ D) (complete2-carrier D) Φ x → Φ x)
        (λx p. fst p);

– The second projection will also be useful. It retrieves the
– memoisation table below the current element. We use the ‘unstep’
– function to make such that this definition is meaningful and usable.
complete2-snd :
  (D : Desc) →
  (Φ : µ D → Set 1) →
  (x : µ D) →
  semI' (µ D) (µ D) (complete2-carrier D) Φ x →
  lift' D (µ D) (semI' (µ D) (µ D) (complete2-carrier D) Φ) (deconstruct D x);
complete2-snd D Φ =
  caseD D (λx. semI' (µ D) (µ D) (complete2-carrier D) Φ x →
               lift' D (µ D) (semI' (µ D) (µ D) (complete2-carrier D) Φ) (deconstruct D x))
    (λx p. unstep D (complete2-carrier D) Φ x (snd p));

– This other second projection goes an extra step to translate between
– the computed lifting type and the of description the lifting.
complete2-snd2 :
  (D : Desc) →
  (Φ : µ D → Set 1) →
  (x : µ D) →
  semI' (µ D) (µ D) (complete2-carrier D) Φ x →
  semI' (µ D) (µ D) (fst (desc-inductor D)) (semI' (µ D) (µ D) (complete2-carrier D) Φ) x;
complete2-snd2 D Φ x p =
  lift-to-lift2 D (µ D) (semI' (µ D) (µ D) (complete2-carrier D) Φ) (deconstruct D x) (complete2-snd D Φ x p);


– The lifting ‘lift D’ has similar structure to an applicative
– functor. This is used in the definitions of the cojoin and the
– distributive law.
apply :
 (D : Desc) →
 (A : Set) →
 (Φ Ψ : A → Set 1) →
 (x : sem D A) →
 lift' D A (λa. Φ a → Ψ a) x →
 lift' D A Φ x →
 lift' D A Ψ x;
apply D A Φ Ψ =
  elimD (λD. (x : sem D A) →
             lift' D A (λa. Φ a → Ψ a) x →
             lift' D A Φ x →
             lift' D A Ψ x)
    (λA a u₁ u₂. ⋄)
    (λx f. f)
    (λD₁ D₂ ap₁ ap₂ x f φ. « ap₁ (fst x) (fst f) (fst φ), ap₂ (snd x) (snd f) (snd φ) »)
    (λD₁ D₂ ap₁ ap₂ x.
      case x with
        { inl x₁. ap₁ x₁
        ; inr x₂. ap₂ x₂
        })
    D;

– One direction of truth preservation gives the unit. This isn't
– actually used below, but is here for completeness.
unit : (A : Set) →
       (D : Desc) →
       (x : sem D A) →
       lift' D A (λx. Unit) x;
unit A = elimD
  (λD. (x : sem D A) → lift' D A (λx. Unit) x)
  (λA x. ⋄)
  (λa. ⋄)
  (λD₁ D₂ unit₁ unit₂ x.
    « unit₁ (fst x), unit₂ (snd x) »)
  (λD₁ D₂ unit₁ unit₂ x.
    case x with
      { inl x₁. unit₁ x₁
      ; inr x₂. unit₂ x₂
      });

– We can now define the cojoin of the complete-induction comonad.
complete2-cojoin :
  (D : Desc) →
  (Φ : µ D → Set 1) →
  (x : µ D) →
  semI' (µ D) (µ D) (complete2-carrier D) Φ x →
  semI' (µ D) (µ D) (complete2-carrier D) (semI' (µ D) (µ D) (complete2-carrier D) Φ) x;
complete2-cojoin D Φ =
  induction D
    (λx. semI' (µ D) (µ D) (complete2-carrier D) Φ x →
         semI' (µ D) (µ D) (complete2-carrier D) (semI' (µ D) (µ D) (complete2-carrier D) Φ) x)
    (λx p q.
      « q
      , step D (complete2-carrier D) (semI' (µ D) (µ D) (complete2-carrier D) Φ) x
          (apply D (µ D)
            (semI' (µ D) (µ D) (complete2-carrier D) Φ)
            (semI' (µ D) (µ D) (complete2-carrier D) (semI' (µ D) (µ D) (complete2-carrier D) Φ))
            x
            p
            (complete2-snd D Φ (construct x) q))
      »);

– And the distributive law. Given the structure exposed above, this
– isn't quite as scary as it looks. Quite a lot of the text is composed
– of type annotations due to the lack of any kind of type reconstruction
– in this system. Also, the ‘step’ and ‘lift2-to-lift’ are basically
– just bureaucratic fluff.
complete2-dist :
  (D : Desc) →
  (P : µ D → Set 1) →
  (x : µ D) →
  semI' (µ D) (µ D) (fst (desc-inductor D)) (semI' (µ D) (µ D) (complete2-carrier D) P) x →
  semI' (µ D) (µ D) (complete2-carrier D) (semI' (µ D) (µ D) (fst (desc-inductor D)) P) x;
complete2-dist D P =
  induction D
    (λx. semI' (µ D) (µ D) (fst (desc-inductor D)) (semI' (µ D) (µ D) (complete2-carrier D) P) x →
         semI' (µ D) (µ D) (complete2-carrier D) (semI' (µ D) (µ D) (fst (desc-inductor D)) P) x)
    (λx dist y.
      « map (µ D) (fst (desc-inductor D) (construct x))
          (semI' (µ D) (µ D) (complete2-carrier D) P)
          P
          (complete2-counit D P)
          y
      , step D (complete2-carrier D) (semI' (µ D) (µ D) (fst (desc-inductor D)) P)
          x
          (apply D (µ D)
            (semI' (µ D) (µ D) (fst (desc-inductor D)) (semI' (µ D) (µ D) (complete2-carrier D) P))
            (semI' (µ D) (µ D) (complete2-carrier D) (semI' (µ D) (µ D) (fst (desc-inductor D)) P))
            x
            dist
            (lift2-to-lift D (µ D)
              (semI' (µ D) (µ D) (fst (desc-inductor D)) (semI' (µ D) (µ D) (complete2-carrier D) P))
              x
              (map (µ D) (fst (desc-inductor D) (construct x))
                (semI' (µ D) (µ D) (complete2-carrier D) P)
                (semI' (µ D) (µ D) (fst (desc-inductor D)) (semI' (µ D) (µ D) (complete2-carrier D) P))
                (complete2-snd2 D P)
                y)))
      »);

– And now, after all that, a new induction principle for ‘µ D’:
complete-inductor :
  (D : Desc) →
  inductor (µ D);
complete-inductor D =
  comonadic-inductor (µ D)
    « complete2-carrier D, « complete2-counit D, « complete2-cojoin D, ⋄ »»»
    (desc-inductor D)
    (complete2-dist D);

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– Enough abstract nonsense. Let's try out all this theory on a proper
– real world problem close to functional programmer's hearts: fibonacci.

data Nat : Set :=
  | zero :
  | succ : Nat
  ;

– To keep with the theme of this file, these should be expressed as
– inductors, but it is just easier to do it like this for now.
caseNat :
  (Φ : Nat → Set 2) →
  (Φ zero) →
  ((n : Nat) → Φ (succ n)) →
  (n : Nat) → Φ n;
caseNat Φ φzero φsucc =
  induction NatDesc (λn. Φ n)
    (λx p. case x with
             { inl u. φzero
             ; inr n. φsucc n
             });

natInduction : (Φ : Nat → Set 2) →
               (Φ zero) →
               ((n : Nat) → Φ n → Φ (succ n)) →
               (n : Nat) → Φ n;
natInduction Φ φ0 φS =
  induction NatDesc (λn. Φ n)
            (\x. case x with
                    { inl u. \u'. φ0
                    ; inr n. \φn. φS n φn
                    });

– Adding natural numbers.
add : Nat → Nat → Nat;
add n₁ n₂ = natInduction (λx. Nat) n₂ (λx. succ) n₁;

one : Nat;
one = succ zero;

two : Nat;
two = add one one;

four : Nat;
four = add two two;

five : Nat;
five = succ four;

eight : Nat;
eight = add four four;

P : Nat → Set 2;
P n = semI' Nat Nat (fst (complete-inductor NatDesc)) (λn. Nat) n → Nat;

fibonacci : Nat → Nat;
fibonacci =
  snd (complete-inductor NatDesc) (λn. Nat)
    (caseNat P
       (λd. one) – fibonacci 0 = 1
       (caseNat (λn. P (succ n))
         (λd. one) – fibonacci 1 = 1
         (λn p. add (fst p) (complete2-counit NatDesc (λn. Nat) n (snd p)))));

– Note that we had to use the counit to get hold of next number in the
– table below the one that was opened up by doing the case
– analysis. This is a bit untidy.


– A test, using Leibniz equality as the comparison.
nat-equal : Nat → Nat → Set 2;
nat-equal n₁ n₂ = (F : Nat → Set 1) → F n₁ → F n₂;

nat-refl : (a : Nat) → nat-equal a a;
nat-refl a = λF x. x;

– This will make the typechecker normalise both sides and compare
– them. If this works, the implementation above will have computed
– fibonacci 5 correctly.
test : nat-equal (fibonacci five) eight;
test = λF x. x;

– Yay it works!

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– GCD, another example. Suggested by Ben and Pierre.
equalNat : Nat → Nat → Set;
equalNat = natInduction (λx. Nat → Set)
                        (caseNat (λx. Set) Unit (λn. Empty))
                        (λn f. caseNat (λx. Set) Empty f);

equalNat-refl : (n : Nat) → equalNat n n;
equalNat-refl = natInduction (λn. equalNat n n) ⋄ (λn p. p);

equal-to-leibniz : (n₁ n₂ : Nat) → equalNat n₁ n₂ → nat-equal n₁ n₂;
equal-to-leibniz =
  natInduction (λn₁. (n₂ : Nat) → equalNat n₁ n₂ → nat-equal n₁ n₂)
               (caseNat (λn₂. equalNat zero n₂ → nat-equal zero n₂)
                        (λu. nat-refl zero)
                        (λn₂ e. elimEmpty e for nat-equal zero (succ n₂)))
               (λn₁ ih. caseNat (λn₂. equalNat (succ n₁) n₂ → nat-equal (succ n₁) n₂)
                                (λe. elimEmpty e for nat-equal (succ n₁) zero)
                                (λn₂ eq. λF f₁. ih n₂ eq (λn. F (succ n)) f₁));

compareView : Nat → Nat → Set;
compareView n₁ n₂ =
    equalNat n₁ n₂
  + ((k : Nat) × equalNat (succ (add n₁ k)) n₂)
  + ((k : Nat) × equalNat (succ (add n₂ k)) n₁);

compare : (n₁ n₂ : Nat) → compareView n₁ n₂;
compare =
  natInduction (λn₁. (n₂ : Nat) → compareView n₁ n₂)
    (caseNat (λn₂. compareView zero n₂)
       (inl ⋄)
       (λn₂. inr (inl «n₂, equalNat-refl n₂»)))
    (λn₁ compare.
     caseNat (λn₂. compareView (succ n₁) n₂)
       (inr (inr «n₁, equalNat-refl n₁»))
       compare);

project :
  (Φ : Nat → Set) →
  (n : Nat) →
  semI[fst (complete-inductor NatDesc) (succ n), n. Φ n] →
  Φ n;
project Φ =
  caseNat (λn. semI[fst (complete-inductor NatDesc) (succ n), n. Φ n] → Φ n)
  (λx. fst x)
  (λn x. fst x);

stepDown :
  (Φ : Nat → Set) →
  (n : Nat) →
  semI[fst (complete-inductor NatDesc) (succ n), n. Φ n] →
  semI[fst (complete-inductor NatDesc) n, n. Φ n];
stepDown Φ =
  caseNat (λn. semI[fst (complete-inductor NatDesc) (succ n), n. Φ n] →
               semI[fst (complete-inductor NatDesc) n, n. Φ n])
  (λx. ⋄)
  (λn x. snd x);

descend : (Φ : Nat → Set) →
          (k n₁ n₂ : Nat) →
          equalNat (succ (add n₁ k)) n₂ →
          semI[fst (complete-inductor NatDesc) n₂, n. Φ n] →
          Φ k;
descend Φ k =
  natInduction
    (λn₁. (n₂ : Nat) →
          equalNat (succ (add n₁ k)) n₂ →
          semI[fst (complete-inductor NatDesc) n₂, n. Φ n] →
          Φ k)
    (λn₂ eq.
       equal-to-leibniz (succ k) n₂ eq
         (λn₂. semI[fst (complete-inductor NatDesc) n₂, n. Φ n] → Φ k)
         (project Φ k))
    (λn₁ ih n₂ eq.
       equal-to-leibniz (succ (succ (add n₁ k))) n₂ eq
        (λn₂. semI[fst (complete-inductor NatDesc) n₂, n. Φ n] → Φ k)
        (λφ. ih (succ (add n₁ k)) (equalNat-refl (succ (add n₁ k))) (stepDown Φ (succ (add n₁ k)) φ)));

switch :
  (n₁ n₂ : Nat) →
  equalNat (add (succ n₁) n₂) (add n₁ (succ n₂));
switch =
  natInduction (λn₁. (n₂ : Nat) → equalNat (add (succ n₁) n₂) (add n₁ (succ n₂)))
    (λn₂. equalNat-refl n₂)
    (λn₁ ih. ih);

descend-gcd :
  (Φ : Nat → Set) →
  (k n₁ n₂ : Nat) →
  equalNat (succ (add (succ n₁) k)) n₂ →
  semI[fst (complete-inductor NatDesc) n₂, n. Φ n] →
  Φ (succ k);
descend-gcd Φ k n₁ n₂ eq =
  descend Φ (succ k) n₁ n₂
    (equal-to-leibniz
      (succ (add (succ n₁) k))
      (succ (add n₁ (succ k)))
      (switch n₁ k)
      (λn. equalNat n n₂)
      eq);

caseNatPair :
  (Φ : Nat → Nat → Set 2) →
  (Φ zero zero) →
  ((n : Nat) → Φ zero (succ n)) →
  ((n : Nat) → Φ (succ n) zero) →
  ((n₁ n₂ : Nat) → Φ (succ n₁) (succ n₂)) →
  (p : Nat × Nat) → Φ (fst p) (snd p);
caseNatPair Φ φzz φzs φsz φss p =
  caseNat (λn₁. (n₂ : Nat) → Φ n₁ n₂)
    (caseNat (λn₂. Φ zero n₂) φzz φzs)
    (λn₁. caseNat (λn₂. Φ (succ n₁) n₂) (φsz n₁) (φss n₁))
    (fst p) (snd p);

GCD-inductor : inductor (Nat × Nat);
GCD-inductor =
  pair-inductor Nat (complete-inductor NatDesc)
                Nat (complete-inductor NatDesc);

gcd : Nat → Nat → Nat;
gcd n₁ n₂ =
  snd GCD-inductor (λp. Nat)
    (caseNatPair
       (λn₁ n₂. semI[fst GCD-inductor «n₁,n₂», n. Nat] → Nat)
       (λφ. zero)
       (λn φ. n)
       (λn φ. n)
       (λn₁ n₂ φ.
          case compare (succ n₁) (succ n₂) with
            { inl e. succ n₁
            ; inr s. case s with
               { inl lt. descend-gcd (λn. Nat) (fst lt) n₁ (succ n₂) (snd lt)
                         (commute2 Nat (Nat × Nat)
                                   (fst (complete-inductor NatDesc) (succ n₂))
                                   (bloo Nat Nat (succ n₁)) (λn. Nat) (snd φ))
               ; inr gt. descend-gcd (λn. Nat) (fst gt) n₂ (succ n₁) (snd gt)
                         (commute2 Nat (Nat × Nat)
                                   (fst (complete-inductor NatDesc) (succ n₁))
                                   (floo Nat Nat (succ n₂)) (λn. Nat) (fst φ))
               }
            }))
    « n₁, n₂ »;

– a test:
nine : Nat;
nine = succ eight;

six : Nat;
six = add four two;

three : Nat;
three = succ two;

test-gcd : nat-equal (gcd nine six) three;
test-gcd F x = x;

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– Possible alternative formulation of inductors that works towards
– statement of their computational behaviour.

– The idea is a explicit type of “substructure” is pulled out. For
– instance, for an inductor for the type ‘µ D’ the substructure type
– would be ‘sem D (µ D)’. This makes the description of inductor more
– like the abstract categorical formulation.
inductor2 : Set → Set 3;
inductor2 A = (B    : Set) ×
              (cons : B → A) ×
              (H    : B → IDesc A) ×
              ((Φ : A → Set 1) →
               ((x : B) → semI' B A H Φ x → Φ (cons x)) →
               (x : A) → Φ x);

– Now we can expect that attempting to reduce against (cons b) should
– do something, computationally.

– Given the difficulty with defining a carrier for complete induction,
– I now think that the ‘inductor2’ formulation is more likely to be
– the correct one. Also, we seemed to need ‘caseNat’ above to actually
– get anywhere.