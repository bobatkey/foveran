sem : Desc → Set → Set ;
sem = elimD (λx → Set → Set)
            (λA X → A)
            (λX → X)
            (λF G semF semG X → semF X × semG X)
            (λF G semF semG X → semF X + semG X);

lift : (D : Desc) →
       (α : Set) →
       (Φ : α → Set 2) →
       sem D α →
       Set 2 ;
lift D α Φ = elimD (\D → sem D α → Set 2)
                   (\A x → Unit)
                   (\x → Φ x)
                   (\F G f g x → f (fst x) × g (snd x))
                   (\F G f g x → case x for d. Set 2 with
                                   { inl y → f y
                                   ; inr z → g z
                                   })
                   D;

deconstruct'' : (F : Desc) → µ F → sem F (µ F) ;
deconstruct'' F = induction F (\x → sem F (µ F)) (\x p → x);

-- is it possible to automatically do the refinement process in the
-- theory as it stands? That is, given a basic datatype and a refining
-- algebra, use the underlying + equality as the carrier and give an
-- induction principle and constructors for it with the correct
-- computational rules?

data Nat : Set :=
  | zero :
  | succ : Nat
  ;

natInduction : (Φ : Nat → Set 2) →
               (Φ zero) →
               ((n : Nat) → Φ n → Φ (succ n)) →
               (n : Nat) → Φ n;
natInduction Φ φ0 φS =
  induction NatDesc Φ
            (\x → case x for x. lift NatDesc Nat Φ x → Φ (construct NatDesc x) with
                    { inl u → \u' → φ0
                    ; inr n → \φn → φS n φn
                    });

caseNat : (A : Set 2) → A → (Nat → A) → Nat → A ;
caseNat A a f n = case deconstruct'' NatDesc n for x. A with
                    { inl u → a
                    ; inr n → f n
                    };

data List (A : Set) : Set :=
  | nil  :
  | cons : A List
  ;

lengthAlg : (A : Set) → sem (ListDesc A) Nat → Nat ;
lengthAlg A x = case x for x. Nat with
                  { inl u → zero
                  ; inr p → succ (snd p)
                  };

-- inverse image along lengthAlg:
invLength : (A : Set) →
            (sem (ListDesc A) Nat → Set) →
            Nat → Set;
invLength A X n = caseNat Set (X (inl ()))
                              (λn → (a : A) × X (inr «a,n»))
                              n;

lift2 : (D : Desc) →
        (α : Set) →
        (Φ : α → Set) →
        sem D α →
        Set ;
lift2 D α Φ = elimD (\D → sem D α → Set)
                    (\A x → Unit)
                    (\x → Φ x)
                    (\F G f g x → f (fst x) × g (snd x))
                    (\F G f g x → case x for d. Set with
                                    { inl y → f y
                                    ; inr z → g z
                                    })
                    D;


– Now, if we compose invLength and lift, we get F^lengthAlg
FlengthAlg : Set → (Nat → Set) → (Nat → Set);
FlengthAlg A X = invLength A (lift2 (ListDesc A) Nat X);

– let's trick the system into normalising it, so we can have a look at it
–X : (A : Set) → (F : ((Nat → Set) → (Nat → Set)) → Set) → (x : (Nat → Set) → (Nat → Set)) → F (FlengthAlg A) → F x;
–X A F x a = a;

– How do we get a fix point of this? In general?
assume eqNat : Nat → Nat → Set;

assume length : (A : Set) → List A → Nat ;

muFlength : Set → Nat → Set;
muFlength A n = (l : List A) × eqNat (length A l) n;

– there just so happens, in this case, to be an object that represents muFlength2
muFlength2 : Set → Nat → Set;
muFlength2 A = natInduction (λn → Set)
                            Unit
                            (λn X → A × X);

destructNat : (Φ : Nat → Set 2) → Φ zero → ((n : Nat) → Φ (succ n)) → (n : Nat) → Φ n;
destructNat Φ z s = natInduction Φ z (λn p → s n);

inVec : (A : Set) → (n : Nat) → FlengthAlg A (muFlength2 A) n → muFlength2 A n;
inVec A = destructNat (λn → FlengthAlg A (muFlength2 A) n → muFlength2 A n)
                      (λu → u)
                      (λn p → «fst p, snd (snd p)»);

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
– we can use the fact that lift is also expressible as an indexed type, and so
– if we had indexed descriptions, we could 
assume IDesc : Set → Set 1;
assume UnitD : (α : Set) → IDesc α;
assume Rec   : (α : Set) → α → IDesc α;
assume Pair  : (α : Set) → IDesc α → IDesc α → IDesc α;
assume Sg    : (α : Set) → (β : Set) → (β → IDesc α) → IDesc α;

lift3 : (D : Desc) →
        (α : Set) →
        sem D α →
        IDesc α;
lift3 D α = elimD (λD → sem D α → IDesc α)
                  (λA x → UnitD α)
                  (λx → Rec α x)
                  (λF G f g x → Pair α (f (fst x)) (g (snd x)))
                  (λF G f g x → case x for d. IDesc α with
                                  { inl y → f y
                                  ; inr z → g z
                                  })
                  D;

– this is a big different, because it acts on functors, not on indexed sets
invLength2 : (A α : Set) → (sem (ListDesc A) Nat → IDesc α) → Nat → IDesc α ;
invLength2 A α X n = caseNat (IDesc α)
                             (X (inl ()))
                             (λn → Sg α A (λa → X (inr «a,n»)))
                             n;

FlengthAlg2 : Set → Nat → IDesc Nat;
FlengthAlg2 A = invLength2 A Nat (lift3 (ListDesc A) Nat);

– let's trick the system into normalising it, so we can have a look at it
X : (A : Set) → (F : (Nat → IDesc Nat) → Set) → (x : Nat → IDesc Nat) → F (FlengthAlg2 A) → F x;
X A F x a = a;

– “theorems for free”:
assume muI : (α : Set) → (α → IDesc α) → α → Set;

assume f : (A : Set) → (n : Nat) → muI (FlengthAlg2 A) n → List; – st length (f A n v) = n

assume g : (A : Set) → (l : List) → muI (FlengthAlg2 A) (length l);

– how to express this property about the length? Need something about
– the relationship between invLength2 and knowing about the length.
