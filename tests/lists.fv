data Nat : Set where
  zero : Nat
  succ : Nat -> Nat

zero : Nat
zero = construct «inl (), refl»

succ : Nat -> Nat
succ n = construct «inr (), n, refl»

--------------------------------------------------------------------------------
data List (A : Set) : Set where
  nil  : List A
  cons : A -> List A -> List A

nil : (A : Set) -> List A
nil A = construct «inl (), refl»

cons : (A : Set) -> A -> List A -> List A
cons A a l = construct «inr (), a, l, refl»

elimList :
  (A : Set) ->
  (P : List A -> Set 2) ->
  (P (nil A)) ->
  ((a : A) -> (l : List A) -> P l -> P (cons A a l)) ->
  (l : List A) ->
  P l
elimList A P pnil pcons l =
  eliminate l with _ «constructor,arguments» p.
    generalise p then
    generalise arguments then
    case constructor with
      { inl _. λeq       _.     rewriteBy eq then pnil
      ; inr _. λ«a,l,eq» «p,_». rewriteBy eq then pcons a l p
      }

map : (A B : Set) ->
      (A -> B) ->
      List A ->
      List B
map A B f l =
  eliminate l with _ «c,d» p.
    generalise p then
    generalise d then
    case c with
      { inl _. \eq         _.          nil B
      ; inr _. \«a, l, eq» «map_l, _». cons B (f a) map_l
      }

length : (A : Set) -> List A -> Nat
length A l =
  eliminate l with _ «c,d» p.
    generalise p then
    generalise d then
    case c with
      { inl _. \_ _.             zero
      ; inr _. \_ «length_l, _». succ length_l
      }

;
