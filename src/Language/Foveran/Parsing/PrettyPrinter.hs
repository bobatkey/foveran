{-# LANGUAGE OverloadedStrings #-}

module Language.Foveran.Parsing.PrettyPrinter
    ( ppAnnotTerm 
    , ppAnnotTermLev
    , ppPlain
    , ppIDataDecl
    , ppIdent
    , ppDeclarations
    )
    where

import           Data.String
import           Data.List (intersperse)
import           Data.Functor ((<$>))
import           Data.Pair
import           Data.Monoid (mempty)
import           Data.Maybe (fromMaybe)
import           Data.Rec (foldAnnot, Rec, foldRec, AnnotRec (..))
import           Text.PrettyPrintPrec
import qualified Text.PrettyPrint as PP
import           Language.Foveran.Syntax.Display
import qualified Data.Text as T

ppIdent :: IsString a => T.Text -> a -- FIXME: define a type class for pretty printers
ppIdent = fromString . T.unpack
ppIdents = hsep . map ppIdent

ppPattern :: Pattern -> PrecDoc
ppPattern (PatVar nm)  = ppIdent nm
ppPattern (PatTuple l) = "«" <> hsep (punctuate "," $ map ppPattern l) <> "»"
ppPattern PatNull      = "_"

ppPatterns :: [Pattern] -> PrecDoc
ppPatterns = hsep . map ppPattern

pprint :: TermCon PrecDoc -> PrecDoc
pprint (Var nm) = ppIdent nm
pprint (Set 0)  = "Set"
pprint (Set l)  = "Set" <+> int l

pprint (Pi bs t) = paren 10 $ sep (map doBinder bs ++ [t])
    where doBinder ([], t) = down t <+> "->"
          doBinder (nms,t) = "(" <> ppPatterns nms <+> ":" <+> t <> ")" <+> "->"
pprint (Lam [] t)     = t -- FIXME this case shouldn't ever happen, but they get generated by the DataDecl stuff
pprint (Lam nms t)    = paren 10 (sep ["\\" <> ppPatterns nms <> ".", nest 4 t])
pprint (App t ts)     = paren 01 (sep (t:map (nest 2 . down) ts))

pprint (Prod t1 t2)      = paren 08 (down t1 <+> "×" <+> t2)
pprint (Sigma nms t1 t2) = paren 10 (hang ("(" <> ppPatterns nms <+> ":" <+> t1 <> ")" <+> "×") 0 t2)
pprint (Proj1 t)         = paren 01 ("fst" <+> down t) -- These precs are a hack to make the output look less weird
pprint (Proj2 t)         = paren 01 ("snd" <+> down t)
pprint (Tuple tms)       = "«" <> (sep $ punctuate "," $ map resetPrec tms) <> "»"

pprint (Sum t1 t2)             = paren 09 (down t1 <+> "+" <+> t2)
pprint (Inl t)                 = paren 01 ("inl" <+> down t)
pprint (Inr t)                 = paren 01 ("inr" <+> down t)
pprint (Case t tP y tL z tR) =
    ("case" <+> t <+> (maybe "" (\(x,tP) -> "for" <+> ppIdent x <> "." <+> resetPrec tP) tP) <+> "with")
    $$
    nest 2 (("{" <+> hang ("inl" <+> ppPattern y <> ".") 3 (resetPrec tL))
            $$
            (";" <+> hang ("inr" <+> ppPattern z <> ".") 3 (resetPrec tR))
            $$
            "}")
pprint Unit                = "Unit"
pprint UnitI               = "()"
pprint Empty               = "Empty"
pprint (ElimEmpty t1 Nothing)   =
    paren 01 ("absurdBy" <+> resetPrec t1)
pprint (ElimEmpty t1 (Just t2)) =
    paren 01 ("absurdBy" <+> resetPrec t1 $$ nest 6 "for" <+> resetPrec t2)

pprint (Eq t1 t2)          = paren 07 (sep [down t1, nest 2 "==", t2])
pprint Refl                = "refl"
pprint (ElimEq t Nothing t2) =
    paren 01 ("rewriteBy" <+> resetPrec t <+> "then" $$ resetPrec t2)
pprint (ElimEq t (Just (a, e, t1)) t2) =
    paren 01 ("rewriteBy" <+> resetPrec t
              $$ nest 3 "for" <+> ppIdent a <+> ppIdent e <> "." <+> resetPrec t1
              $$ nest 2 "then" <+> resetPrec t2)

pprint (Desc_K t)          = paren 01 ("\"K\"" <+> down t)
pprint (Desc_Prod t1 t2)   = paren 08 (sep [down t1, nest 2 "\"×\"", t2])
pprint (Construct t)       = paren 01 ("construct" <+> down t)

pprint IDesc               = "IDesc"
pprint (IDesc_Id t)        = paren 01 ("\"IId\"" <+> down t)
pprint (IDesc_Sg t1 t2)    = paren 01 ("\"Sg\"" <+> (down t1 $$ down t2))
pprint (IDesc_Pi t1 t2)    = paren 01 ("\"Pi\"" <+> down t1 <+> down t2)
pprint (IDesc_Bind t1 x t2) = paren 09 (sep [ "bind" <+> ppPattern x <+> "<-" <+> resetPrec t1 <+> "in"
                                            , nest 2 (resetPrec t2)])
pprint IDesc_Elim          = "elimID"
pprint (SemI tD i tA)      =
    resetPrec $ "semI" <> hcat [ "["
                               , sep $ punctuate "," [ tD, ppPattern i <> "." <+> tA ]
                               ,  "]" ]
pprint (MapI tD i1 tA i2 tB tf tx) =
    resetPrec $ "mapI" <> hcat [ "["
                               , sep $ punctuate "," [ tD
                                                     , ppPattern i1 <> "." <+> tA
                                                     , ppPattern i2 <> "." <+> tB
                                                     , tf
                                                     , tx ]
                               , "]" ]
pprint (LiftI tD x tA i a tP tx) =
    resetPrec $ "liftI" <> hcat [ "["
                                , sep $ punctuate "," [ tD
                                                      , ppPattern x <> "." <+> tA
                                                      , ppPattern i <+> ppPattern a <> "." <+> tP
                                                      , tx ]
                                , "]" ]
pprint (MuI t1 t2)         = paren 01 ("muI" <+> sep [down t1, down t2])
pprint (Eliminate t Nothing i x p tK) =
    "eliminate" <+> t <+> "then" <+> ppPattern i <+> ppPattern x <+> ppPattern p <> "." $$
    nest 2 tK
pprint (Eliminate t (Just (iP,xP,tP)) i x p tK) =
    "eliminate" <+> t <+>
    "for" <+> ppPattern iP <+> ppPattern xP <> "." <+> tP <+>
    "then" <+> ppPattern i <+> ppPattern x <+> ppPattern p <> "."
    $$ nest 2 tK

pprint (NamedConstructor nm [])  = paren 00 (ppIdent nm)
pprint (NamedConstructor nm tms) = paren 01 (sep (ppIdent nm: map (nest 2 . down) tms))
pprint (CasesOn isRecursive t clauses)      =
    (if isRecursive then "recursionOn" else "casesOn")
    <+> t <+> "with" $$ nest 2 (doClauses clauses)
    where doClauses []             = "{" <+> "}"
          doClauses (clause1:rest) = ("{" <+> doClause clause1) $$ doOtherClauses rest

          doOtherClauses []       = "}"
          doOtherClauses (c:rest) = (";" <+> doClause c) $$ doOtherClauses rest

          doClause (ident, patterns, tm) =
              sep [ppIdent ident <+> ppPatterns patterns <> ".", nest 2 tm]
pprint (RecurseOn nm) = paren 01 ("recurseOn" <+> ppIdent nm)

pprint (Group nm NotAbelian ty) = "Group[" <> ppIdent nm <> maybe empty (comma <+>) ty <> "]"
pprint (Group nm IsAbelian ty)  = "AbGroup[" <> ppIdent nm <> maybe empty (comma <+>) ty <> "]"
pprint GroupUnit           = "unit"
pprint (GroupMul t1 t2)    = paren 08 (t1 <+> "#" <+> down t2)
pprint (GroupInv t)        = paren 07 ("inv" <+> down t)

pprint (TypeAscrip t1 t2)  = paren 06 (down t1 <+> ":" <+> down t2)

pprint (Generalise t1 t2)  = paren 01 ("generalise" <+> resetPrec t1 <+> "then"
                                       $$ resetPrec t2)

pprint (LabelledType nm args ty) =
    resetPrec ("<" <+> ppIdent nm <+> sep (map (\(Pair t ty) -> "(" <+> t <+> ":" <+> ty <+> ")") args) <+> ":" <+> ty <+> ">")
pprint (Return t) =
    paren 01 ("return" <+> down t)
pprint (Call t) =
    paren 01 ("call" <+> down t)

pprint UserHole            = "?"
pprint (Hole nm tms)       = "?" <> ppIdent nm <> "{" <> hcat (punctuate "," (map resetPrec (reverse tms))) <> "}"

ppAnnotTerm :: TermPos -> PP.Doc
ppAnnotTerm t = foldAnnot pprint t `atPrecedenceLevel` 10

ppAnnotTermLev :: Int -> TermPos -> PP.Doc
ppAnnotTermLev l t = foldAnnot pprint t `atPrecedenceLevel` l

ppPlain :: Rec TermCon -> PP.Doc
ppPlain t = foldRec pprint t `atPrecedenceLevel` 10

--------------------------------------------------------------------------------
ppDefinition :: Definition -> PP.Doc
ppDefinition (Definition _ nm1 ty nm2 argPatterns tm) =
    (sep [ppIdent nm1 <+> ":", nest 2 (foldAnnot pprint ty <> ";")]
     $$
     sep [ hsep (ppIdent nm1:map ppPattern argPatterns) <+> "="
         , nest 2 (foldAnnot pprint tm <> ";")]) `atPrecedenceLevel` 10

--------------------------------------------------------------------------------
ppIDataDecl :: IDataDecl -> PP.Doc
ppIDataDecl d = doc `atPrecedenceLevel` 10
    where
      doc = ("data" <+>
             ppIdent (dataName d) <+>
             hsep [ "(" <> ppIdent nm <+> ":" <+> fromDoc (ppAnnotTerm t) <> ")" | DataParameter _ nm t <- dataParameters d ] <+>
             ":" <> fromMaybe "" (fmap ((" " <>) . (<+> "->") . fromDoc . ppAnnotTermLev 9) (dataIndexType d)) <+> "Set" <+> "where")
            $$ nest 2 (doConstructors (dataConstructors d))

      doConstructors []     = "{ };"
      doConstructors (c:cs) = vcat (("{" <+> doConstructor c) : map (\c -> ";" <+> doConstructor c) cs) $$ "};"

      doConstructor c = ppIdent (consName c) <+> ":" <+> sep (doBits (consBits c))

      doBits (Annot p (ConsPi nm t xs)) = ("(" <> ppIdent nm <+> ":" <+> fromDoc (ppAnnotTerm t) <> ")" <+> "->") : doBits xs
      doBits (Annot p (ConsArr t xs))   = (fromDoc (ppAnnotTermLev 9 t) <+> "->") : doBits xs
      doBits (Annot p (ConsEnd nm ts))  = [ppIdent nm <+> sep (map (fromDoc . ppAnnotTermLev 0) ts)]

--------------------------------------------------------------------------------
ppDecl :: Declaration -> PP.Doc
ppDecl (AssumptionDecl _)   = mempty
ppDecl (DefinitionDecl def) = ppDefinition def
ppDecl (IDataDecl decl)     = ppIDataDecl decl
ppDecl (Normalise _)        = mempty

ppDeclarations :: [Declaration] -> PP.Doc
ppDeclarations = PP.vcat . intersperse "" . map ppDecl